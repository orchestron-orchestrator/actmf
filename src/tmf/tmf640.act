import base64
import json
import testing
import time

import yang
import yang.gdata
import yang.gen3
from yang.identityref import Identityref, PartialIdentityref
import yang.schema

_NS_TMF = "http://orchestron.org/yang/orchestron-tmf"
def _q(n):
    return yang.gdata.Id(_NS_TMF, n)


extension list[Characteristic] (yang.gen3.YangData):
    def take_container(self, schema: yang.schema.DContainer, name: str, ns_qualified: bool, is_unique: bool, path: list[yang.gen3.PathElement]=[]) -> ?(op: ?str, val: ?value):
        return None

    def take_list(self, schema: yang.schema.DList, name: str, ns_qualified: bool, is_unique: bool, path: list[yang.gen3.PathElement]=[]) -> list[(op: ?str, key: dict[str, value], val: value)]:
        return []

    def take_leaf(self, root: yang.schema.DRoot, schema: yang.schema.DLeaf, name: str, ns_qualified: bool, is_unique: bool, path: list[yang.gen3.PathElement]=[]) -> ?(op: ?str, t: str, val: ?value):
        if isinstance(self, list):
            for entry in self:
                if isinstance(entry, Characteristic):
                    leaf_value = entry.value
                    if entry.name == name and leaf_value is not None:
                        new_path = path + [yang.gen3.PathElement(schema)]
                        if json_type_and_yang_type_match(entry.valueType, schema.type_.builtin_type):
                            tv = yang.gen3.try_parse_json_value(leaf_value, schema, schema.type_, new_path, root)
                            if tv is not None:
                                return (op=None, t=tv.t, val=tv.val)
                        raise yang.gen3.YangValidationError(path, schema.type_, leaf_value)

    def take_leaflist(self, root: yang.schema.DRoot, schema: yang.schema.DLeafList, name: str, ns_qualified: bool, is_unique: bool, path: list[yang.gen3.PathElement]=[]) -> list[(op: ?str, t: str, val: ?value)]:
        if isinstance(self, list):
            for entry in self:
                if isinstance(entry, Characteristic):
                    leaflist_data = entry.value
                    entry_value_type = entry.valueType
                    if entry.name == name and leaflist_data is not None and entry_value_type is not None:
                        if json_type_and_yang_type_match(entry_value_type[:-5] if entry_value_type.endswith("Array") else entry_value_type, schema.type_.builtin_type):
                            if isinstance(leaflist_data, list):
                                new_path = path + [yang.gen3.PathElement(schema)]
                                values: list[(op: ?str, t: str, val: ?value)] = []
                                for item in leaflist_data:
                                    tv = yang.gen3.try_parse_json_value(item, schema, schema.type_, new_path, root)
                                    if tv is not None:
                                        values.append((op=None, t=tv.t, val=tv.val))
                                return values
                        raise yang.gen3.YangValidationError(path, schema.type_, leaflist_data)
        return []

def _get_service_json(layer_config: yang.gdata.Node, top_schema: yang.schema.DRoot, service_id: ?str = None) -> ?value:
    multiple = service_id is None
    services_json = []

    services = layer_config.children[_q("tmf-store")].children[_q("tmf640")].children[_q("service")]
    if isinstance(services, yang.gdata.List):
        for s in services.elements:
            schema = top_schema
            sid = get_child_str(s, _q("id"))
            if not multiple and service_id != sid:
                continue
            service = Service.from_gdata(s)
            config = layer_config
            for path_element in sid.split(".")[:-1]:
                # TODO: include namespace qualifier in service id path (like in JSON, module name)
                schema = schema.get(path_element.split("(")[0])
                fqname = yang.gen3._fqname(schema)
                if "(" in path_element:
                    config = config.children[fqname]
                    key = path_element.split("(")[1].split(")")[0]
                    entry = None
                    if isinstance(config, yang.gdata.List):
                        entry = config.get_opt_list_entry(key)
                    if entry is not None:
                        config = entry
                else:
                    config = config.children[fqname]

            last_path_element = sid.split(".")[-1]
            schema = schema.get(last_path_element.split("(")[0])
            fqname = yang.gen3._fqname(schema)
            config = config.children[fqname]
            if isinstance(config, yang.gdata.List):
                if multiple:
                    for element in config.elements:
                        add_leaf_properties_to_service_characteristics(element, service)
                        services_json.append(service.to_json())
                else:
                    for element in config.elements:
                        if element.get_str(config.keys[0]) == last_path_element.split("(")[1].split(")")[0]:
                            add_leaf_properties_to_service_characteristics(element, service)
                            return service.to_json()

    if multiple:
        return services_json

def get_service_json(layer_config: yang.gdata.Node, top_schema: yang.schema.DRoot, service_id: str) -> ?dict[str, ?value]:
    service = _get_service_json(layer_config, top_schema, service_id)
    if service is not None:
        if isinstance(service, dict):
            return service

def get_service_list_json(layer_config: yang.gdata.Node, top_schema: yang.schema.DRoot) -> list[dict[str, ?value]]:
    services = _get_service_json(layer_config, top_schema)
    if services is not None:
        if isinstance(services, list):
            return services
    return []

def get_service_specification_id(s: ?object) -> str:
    if isinstance(s, Service):
        s_spec = s.serviceSpecification
        if s_spec is not None:
            s_spec_id = s_spec.id
            if s_spec_id is not None:
                return s_spec_id
    elif isinstance(s, ServiceRefOrValue):
        s_spec = s.serviceSpecification
        if s_spec is not None:
            s_spec_id = s_spec.id
            if s_spec_id is not None:
                return s_spec_id
    raise ValueError("Service specification ID not found in Service(RefOrValue)")

def get_key_value(gd: yang.gdata.Node, schema: yang.schema.DNode) -> str:
    if isinstance(schema, yang.schema.DList):
        if len(schema.key) != 1:
            raise NotImplementedError("Service specification with multiple keys not supported")
        key = yang.gdata.Id(schema.namespace, schema.key[0])
        try:
            v = gd.children[key]
            if isinstance(v, yang.gdata.Leaf):
                val = v.val
                if isinstance(val, str):
                    return val
                elif isinstance(val, bigint):
                    return str(val)
                else:
                    raise NotImplementedError(f"Service characteristic key {key} is of type {type(val)}, expected str or bigint")
            else:
                raise NotImplementedError(f"Service characteristic key {key} is of type {type(v)}, expected Leaf")
        except KeyError:
            raise ValueError("Service characteristic key {key} not found in transform data")
    raise NotImplementedError("Expected DList schema for service specification")

def add_key_properties_to_service(service: ?object, gd: yang.gdata.Node, schema: yang.schema.DNode, aggregate_tmf_id: str, path_element: str) -> str:
    if isinstance(service, Service):
        key_value = get_key_value(gd, schema)
        tmf_id = "{path_element}({key_value})"
        aggregate_tmf_id = "{aggregate_tmf_id}.{tmf_id}" if aggregate_tmf_id != "" else tmf_id
        service.id = aggregate_tmf_id
        service.name = key_value
        service.href = "/tmf-api/ServiceActivationAndConfiguration/v4/service/{aggregate_tmf_id}"
        return aggregate_tmf_id
    if isinstance(service, ServiceRefOrValue):
        key_value = get_key_value(gd, schema)
        tmf_id = "{path_element}({key_value})"
        aggregate_tmf_id = "{aggregate_tmf_id}.{tmf_id}" if aggregate_tmf_id != "" else tmf_id
        service.id = aggregate_tmf_id
        service.name = key_value
        service.href = "/tmf-api/ServiceActivationAndConfiguration/v4/service/{aggregate_tmf_id}"
        return aggregate_tmf_id
    raise ValueError("Unsupported service type for adding key properties")

def find_supporting_service_by_path(service: ?object, path: str) -> ?ServiceRefOrValue:
    if isinstance(service, Service):
        for ss in service.supportingService:
            if get_service_specification_id(ss) == path:
                return ss
            return find_supporting_service_by_path(ss, path)
    elif isinstance(service, ServiceRefOrValue):
        current_service_ss = service.supportingService
        for ss in current_service_ss:
            if get_service_specification_id(ss) == path:
                return ss
            return find_supporting_service_by_path(ss, path)

def json_to_gdata(tmf_spec: dict[str, (name: str, description: str)], data: dict[str, ?value], top_schema: yang.schema.DRoot) -> (yang.gdata.Node, str):
    service = Service.from_json(data)
    if service.serviceSpecification.id not in tmf_spec:
        raise ValueError("Invalid service specification {service.serviceSpecification.id}")

    schema = top_schema
    root_path = []
    ret = yang.gdata.Container()
    current_node = ret
    current_path = ""
    aggregate_tmf_id = ""

    for path_element in service.serviceSpecification.id.split("."):
        current_path = path_element if current_path == "" else "{current_path}.{path_element}"
        schema = schema.get(path_element)
        root_path.append("{schema.module}:{schema.name}")
        fqname = yang.gen3._fqname(schema)
        if isinstance(schema, yang.schema.DContainer):
            current_node.children[fqname] = yang.gdata.Container(ns=schema.namespace, module=schema.module)
            current_node = current_node.children[fqname]
            aggregate_tmf_id = "{aggregate_tmf_id}.{path_element}" if aggregate_tmf_id != "" else path_element
        elif isinstance(schema, yang.schema.DList):
            current_node.children[fqname] = yang.gdata.List(
                yang.gen3._fq_list_keys(schema), [], ns=schema.namespace, module=schema.module)
            current_node = current_node.children[fqname]
        else:
            raise NotImplementedError(f"Unexpected GData class {schema.gname} in path resolution")

        ss = find_supporting_service_by_path(service, current_path)
        if ss is not None:
            gd = yang.gen3.from_data(top_schema, ss.serviceCharacteristic, root_path=root_path)
            if gd is not None:
                if isinstance(current_node, yang.gdata.List):
                    current_node.elements.append(gd)
                aggregate_tmf_id = add_key_properties_to_service(ss, gd, schema, aggregate_tmf_id, path_element)
                current_node = gd

    gd = yang.gen3.from_data(top_schema, service.serviceCharacteristic, root_path=root_path)
    if isinstance(current_node, yang.gdata.List):
        current_node.elements.append(gd)

    aggregate_tmf_id = add_key_properties_to_service(service, gd, schema, aggregate_tmf_id, service.serviceSpecification.id.split(".")[-1])
    ret.children[_q("tmf-store")] = yang.gdata.Container({
            _q("tmf640"): yang.gdata.Container({
                _q("service"): yang.gdata.List([_q("id")], [service.to_gdata()])})
                }, ns="http://orchestron.org/yang/orchestron-tmf", module="orchestron-tmf")

    return (ret, aggregate_tmf_id)

def yang_type_to_tmf_type(yt: str) -> str:
    if yt == "boolean":
        return "boolean"
    elif yt == "string":
        return "string"
    elif yt in ["int8", "int16", "int32", "int64", "uint8", "uint16", "uint32", "uint64"]:
        return "integer"
    elif yt == "decimal64":
        return "number"
    elif yt == "enumeration":
        return "string"
    raise ValueError("Unsupported YANG type: %s" % yt)

def gdata_type_to_tmf_type(v: value) -> str:
    if isinstance(v, bool):
        return "boolean"
    elif isinstance(v, str):
        return "string"
    elif isinstance(v, bigint):
        return "integer"
    elif isinstance(v, float):
        return "number"
    elif isinstance (v, list):
        return gdata_type_to_tmf_type(v[0])
    raise ValueError("Unsupported GDATA type: {type(v)}")

def json_type_and_yang_type_match(jt: ?str, yt: ?str) -> bool:
    if jt == "boolean" and yt == "boolean":
        return True
    elif jt == "string" and yt == "string":
        return True
    elif jt == "integer" and yt in ["int8", "int16", "int32", "int64", "uint8", "uint16", "uint32", "uint64"]:
        return True
    elif jt == "number" and yt == "decimal64":
        return True
    elif jt == "string" and yt == "enumeration":
        return True
    return False

def add_leaf_properties_to_service_characteristics(gd: yang.gdata.Node, service: Service) -> None:
    if isinstance(gd, yang.gdata.Container):
        for k, v in gd.children.items():
            if isinstance(v, yang.gdata.Leaf):
                for chr in service.serviceCharacteristic:
                    if chr.name == k.name:
                        chr.valueType = gdata_type_to_tmf_type(v.val)
                        #FIXME: JSON encoder does not support bigint, convert to int
                        val = v.val
                        chr.value = int(val) if isinstance(val, bigint) else val
                        break
            elif isinstance(v, yang.gdata.LeafList):
                for chr in service.serviceCharacteristic:
                    if chr.name == k.name:
                        chr.valueType = "{gdata_type_to_tmf_type(v.vals)}Array"
                        #FIXME: JSON encoder does not support bigint, convert to int
                        chr.value = [int(item) if isinstance(item, bigint) else item for item in v.vals]
                        break

def get_opt_obj(d: dict[str, ?value], key: str) -> ?dict[str, ?value]:
    v = d.get(key)
    if isinstance(v, dict):
        return v

def get_obj(d: dict[str, ?value], key: str) -> dict[str, ?value]:
    v = d.get(key)
    if isinstance(v, dict):
        return v
    raise ValueError("Expected object for key {key}")

def get_opt_int(d: dict[str, ?value], key: str) -> ?int:
    v = d.get(key)
    if isinstance(v, int):
        return v

def get_opt_str(d: dict[str, ?value], key: str) -> ?str:
    v = d.get(key)
    if isinstance(v, str):
        return v

def get_str(d: dict[str, ?value], key: str) -> str:
    v = d.get(key)
    if isinstance(v, str):
        return v
    raise ValueError("Expected string for key {key}")

def get_opt_bool(d: dict[str, ?value], key: str) -> ?bool:
    v = d.get(key)
    if isinstance(v, bool):
        return v

def get_bool(d: dict[str, ?value], key: str) -> bool:
    v = d.get(key)
    if isinstance(v, bool):
        return v
    raise ValueError("Expected bool for key {key}")

def get_opt_float(d: dict[str, ?value], key: str) -> ?float:
    v = d.get(key)
    if isinstance(v, float):
        return v

def get_opt_value(d: dict[str, ?value], key: str) -> ?value:
    v = d.get(key)
    if v is not None:
        return v

def get_child_value(node: yang.gdata.Node, child_name: yang.gdata.Id) -> value:
    child = node.children.get(child_name)
    if isinstance(child, yang.gdata.Leaf):
        return child.val
    raise ValueError("Expected leaf child {child_name}")

def get_child_str(node: yang.gdata.Node, child_name: yang.gdata.Id) -> str:
    child = node.children.get(child_name)
    if isinstance(child, yang.gdata.Leaf):
        child_val = child.val
        if isinstance(child_val, str):
            return child_val
    raise ValueError("Expected leaf child {child_name}")

def get_opt_child_str(node: yang.gdata.Node, child_name: yang.gdata.Id) -> ?str:
    child = node.children.get(child_name)
    if isinstance(child, yang.gdata.Leaf):
        child_val = child.val
        if isinstance(child_val, str):
            return child_val
    return None

def get_opt_child_bool(node: yang.gdata.Node, child_name: yang.gdata.Id) -> ?bool:
    child = node.children.get(child_name)
    if isinstance(child, yang.gdata.Leaf):
        child_val = child.val
        if isinstance(child_val, bool):
            return child_val
    return None

def get_service_specification_ref(d: dict[str, ?value], key: str) -> ServiceSpecificationRef:
    v = d.get(key)
    if isinstance(v, dict):
        return ServiceSpecificationRef.from_json(v)
    raise ValueError("Expected dict for key {key}")

def get_child_service_specification_ref(node: yang.gdata.Node, child_name: yang.gdata.Id) -> ServiceSpecificationRef:
    child = node.children.get(child_name)
    if isinstance(child, yang.gdata.Container):
        return ServiceSpecificationRef.from_gdata(child)
    raise ValueError("Expected container child {child_name}")

def get_service_ref_or_value(d: dict[str, ?value], key: str) -> ServiceRefOrValue:
    v = d.get(key)
    if isinstance(v, dict):
        return ServiceRefOrValue.from_json(v)
    raise ValueError("Expected dict for key {key}")

def get_child_service_ref_or_value(node: yang.gdata.Node, child_name: yang.gdata.Id) -> ServiceRefOrValue:
    child = node.children.get(child_name)
    if isinstance(child, yang.gdata.Container):
        return ServiceRefOrValue.from_gdata(child)
    raise ValueError("Expected container child {child_name}")

def get_opt_time_period(d: dict[str, ?value], key: str) -> ?TimePeriod:
    v = d.get(key)
    if isinstance(v, dict):
        return TimePeriod.from_json(v)

def get_opt_child_time_period(node: yang.gdata.Node, child_name: yang.gdata.Id) -> ?TimePeriod:
    child = node.children.get(child_name)
    if isinstance(child, yang.gdata.Container):
        return TimePeriod.from_gdata(child)
    return None

def add_leafs_to_gdata(elements: dict[yang.gdata.Id, yang.gdata.Node], properties: list[(yang.gdata.Id, ?value, str)]):
    for prop_name, prop_value, prop_type in properties:
        p = prop_value
        if p is not None:
            elements[prop_name] = yang.gdata.Leaf(p)
        else:
            raise ValueError("Property {prop_name} is required for gdata")

def add_opt_leafs_to_gdata(elements: dict[yang.gdata.Id, yang.gdata.Node], properties: list[(yang.gdata.Id, ?value, str)]):
    for prop_name, prop_value, prop_type in properties:
        p = prop_value
        if p is not None:
            elements[prop_name] = yang.gdata.Leaf(p)

def get_list(val: ?value) -> list[dict[str, ?value]]:
    if isinstance(val, list):
        return val
    return []

def get_yang_list_elements(yl: ?yang.gdata.Node) -> list[yang.gdata.Node]:
    if isinstance(yl, yang.gdata.List):
        return yl.elements
    return []

def get_opt_obj_to_json(obj) -> ?dict[str, ?value]:
        o = obj
        if o is None:
            return None
        elif isinstance(o, TimePeriod):
            return o.to_json()
        elif isinstance(o, ServiceSpecificationRef):
            return o.to_json()
        raise Exception("Unsupported type for get_opt_obj_to_json: " + str(type(o)))

def add_opt_obj_to_gdata(elements: dict[yang.gdata.Id, yang.gdata.Node], key: yang.gdata.Id, obj):
    o = obj
    if isinstance(o, TimePeriod):
        elements[key] = o.to_gdata()
    elif isinstance(o, ServiceSpecificationRef):
        elements[key] = o.to_gdata()

class Service(object):
    id: ?str
    href: ?str
    category: ?str
    description: ?str
    endDate: ?str
    hasStarted: ?bool
    isBundle: ?bool
    isServiceEnabled: ?bool
    isStateful: ?bool
    name: ?str
    serviceDate: ?str
    serviceType: ?str
    startDate: ?str
    startMode: ?str
    feature: list[Feature]
    note: list[Note]
    place: list[RelatedPlaceRefOrValue]
    relatedEntity: list[RelatedEntityRefOrValue]
    relatedParty: list[RelatedParty]
    serviceCharacteristic: list[Characteristic]
    serviceOrderItem: list[RelatedServiceOrderItem]
    serviceRelationship: list[ServiceRelationship]
    serviceSpecification: ServiceSpecificationRef
    state: ?str
    supportingResource: list[ResourceRef]
    supportingService: list[ServiceRefOrValue]
    baseType: ?str
    schemaLocation: ?str
    type: ?str

    def __init__(self, id: ?str, href: ?str, category: ?str, description: ?str, endDate: ?str, hasStarted: ?bool, isBundle: ?bool, isServiceEnabled: ?bool, isStateful: ?bool, name: ?str, serviceDate: ?str, serviceType: ?str, startDate: ?str, startMode: ?str, feature: list[Feature], note: list[Note], place: list[RelatedPlaceRefOrValue], relatedEntity: list[RelatedEntityRefOrValue], relatedParty: list[RelatedParty], serviceCharacteristic: list[Characteristic], serviceOrderItem: list[RelatedServiceOrderItem], serviceRelationship: list[ServiceRelationship], serviceSpecification: ServiceSpecificationRef, state: ?str, supportingResource: list[ResourceRef], supportingService: list[ServiceRefOrValue], baseType: ?str, schemaLocation: ?str, type: ?str):
        self.id = id
        self.href = href
        self.category = category
        self.description = description
        self.endDate = endDate
        self.hasStarted = hasStarted if hasStarted is not None else True
        self.isBundle = isBundle if isBundle is not None else False
        self.isServiceEnabled = isServiceEnabled if isServiceEnabled is not None else True
        self.isStateful = isStateful if isStateful is not None else False
        self.name = name
        self.serviceDate = serviceDate if serviceDate is not None else str(time.utcnow())
        self.serviceType = serviceType
        self.startDate = startDate if startDate is not None else str(time.utcnow())
        self.startMode = startMode if startMode is not None else "1"
        self.feature = feature
        self.note = note
        self.place = place
        self.relatedEntity = relatedEntity
        self.relatedParty = relatedParty
        self.serviceCharacteristic = serviceCharacteristic
        self.serviceOrderItem = serviceOrderItem
        self.serviceRelationship = serviceRelationship
        self.serviceSpecification = serviceSpecification
        self.state = state if state is not None else "active"
        self.supportingResource = supportingResource
        self.supportingService = supportingService
        self.baseType = baseType if baseType is not None else "Service"
        self.schemaLocation = schemaLocation if schemaLocation is not None else "/tmf-api/schema/Service/Service.schema.json"
        self.type = type if type is not None else "Service"

    @staticmethod
    def from_json(data: dict[str, ?value]) -> Service:
        return Service(
            get_opt_str(data, "id"),
            get_opt_str(data, "href"),
            get_opt_str(data, "category"),
            get_opt_str(data, "description"),
            get_opt_str(data, "endDate"),
            get_opt_bool(data, "hasStarted"),
            get_opt_bool(data, "isBundle"),
            get_opt_bool(data, "isServiceEnabled"),
            get_opt_bool(data, "isStateful"),
            get_opt_str(data, "name"),
            get_opt_str(data, "serviceDate"),
            get_opt_str(data, "serviceType"),
            get_opt_str(data, "startDate"),
            get_opt_str(data, "startMode"),
            list(map(Feature.from_json, get_list(data.get("feature")))),
            list(map(Note.from_json, get_list(data.get("note")))),
            list(map(RelatedPlaceRefOrValue.from_json, get_list(data.get("place")))),
            list(map(RelatedEntityRefOrValue.from_json, get_list(data.get("relatedEntity")))),
            list(map(RelatedParty.from_json, get_list(data.get("relatedParty")))),
            list(map(Characteristic.from_json, get_list(data.get("serviceCharacteristic")))),
            list(map(RelatedServiceOrderItem.from_json, get_list(data.get("serviceOrderItem")))),
            list(map(ServiceRelationship.from_json, get_list(data.get("serviceRelationship")))),
            get_service_specification_ref(data, "serviceSpecification"),
            get_opt_str(data, "state"),
            list(map(ResourceRef.from_json, get_list(data.get("supportingResource")))),
            list(map(ServiceRefOrValue.from_json, get_list(data.get("supportingService")))),
            get_opt_str(data, "@baseType"),
            get_opt_str(data, "@schemaLocation"),
            get_opt_str(data, "@type")
        )

    def to_json(self) -> dict[str, ?value]:
        return {
            "id": self.id,
            "href": self.href,
            "category": self.category,
            "description": self.description,
            "endDate": self.endDate,
            "hasStarted": self.hasStarted,
            "isBundle": self.isBundle,
            "isServiceEnabled": self.isServiceEnabled,
            "isStateful": self.isStateful,
            "name": self.name,
            "serviceDate": self.serviceDate,
            "serviceType": self.serviceType,
            "startDate": self.startDate,
            "startMode": self.startMode,
            "feature": [f.to_json() for f in self.feature],
            "note": [n.to_json() for n in self.note],
            "place": [p.to_json() for p in self.place],
            "relatedEntity": [re.to_json() for re in self.relatedEntity],
            "relatedParty": [rp.to_json() for rp in self.relatedParty],
            "serviceCharacteristic": [sc.to_json() for sc in self.serviceCharacteristic],
            "serviceOrderItem": [soi.to_json() for soi in self.serviceOrderItem],
            "serviceRelationship": [sr.to_json() for sr in self.serviceRelationship],
            "serviceSpecification": [self.serviceSpecification.to_json()],
            "state": self.state,
            "supportingResource": [sres.to_json() for sres in self.supportingResource],
            "supportingService": [ss.to_json() for ss in self.supportingService],
            "@baseType": self.baseType,
            "@schemaLocation": self.schemaLocation,
            "@type": self.type
        }

    @staticmethod
    def from_gdata(gd: yang.gdata.Node) -> Service:
        if isinstance(gd, yang.gdata.Container):
            return Service(
                get_child_str(gd, _q("id")),
                get_opt_child_str(gd, _q("href")),
                get_opt_child_str(gd, _q("category")),
                get_opt_child_str(gd, _q("description")),
                get_opt_child_str(gd, _q("endDate")),
                get_opt_child_bool(gd, _q("hasStarted")),
                get_opt_child_bool(gd, _q("isBundle")),
                get_opt_child_bool(gd, _q("isServiceEnabled")),
                get_opt_child_bool(gd, _q("isStateful")),
                get_opt_child_str(gd, _q("name")),
                get_opt_child_str(gd, _q("serviceDate")),
                get_opt_child_str(gd, _q("serviceType")),
                get_opt_child_str(gd, _q("startDate")),
                get_opt_child_str(gd, _q("startMode")),
                list(map(Feature.from_gdata, get_yang_list_elements(gd.children.get(_q("feature"))))),
                list(map(Note.from_gdata, get_yang_list_elements(gd.children.get(_q("note"))))),
                list(map(RelatedPlaceRefOrValue.from_gdata, get_yang_list_elements(gd.children.get(_q("place"))))),
                list(map(RelatedEntityRefOrValue.from_gdata, get_yang_list_elements(gd.children.get(_q("relatedEntity"))))),
                list(map(RelatedParty.from_gdata, get_yang_list_elements(gd.children.get(_q("relatedParty"))))),
                list(map(Characteristic.from_gdata, get_yang_list_elements(gd.children.get(_q("serviceCharacteristic"))))),
                list(map(RelatedServiceOrderItem.from_gdata, get_yang_list_elements(gd.children.get(_q("serviceOrderItem"))))),
                list(map(ServiceRelationship.from_gdata, get_yang_list_elements(gd.children.get(_q("serviceRelationship"))))),
                get_child_service_specification_ref(gd, _q("serviceSpecification")),
                get_opt_child_str(gd, _q("state")),
                list(map(ResourceRef.from_gdata, get_yang_list_elements(gd.children.get(_q("supportingResource"))))),
                list(map(ServiceRefOrValue.from_gdata, get_yang_list_elements(gd.children.get(_q("supportingService"))))),
                get_opt_child_str(gd, _q("baseType")),
                get_opt_child_str(gd, _q("schemaLocation")),
                get_opt_child_str(gd, _q("type"))
            )
        raise ValueError("Unsupported gdata node type")

    def to_gdata(self) -> yang.gdata.Node:
        elements = {}
        add_leafs_to_gdata(elements, [
            (_q("id"), self.id, "string")
        ])
        add_opt_leafs_to_gdata(elements, [
            (_q("href"), self.href, "string"),
            (_q("category"), self.category, "string"),
            (_q("description"), self.description, "string"),
            (_q("endDate"), self.endDate, "string"),
            (_q("hasStarted"), self.hasStarted, "boolean"),
            (_q("isBundle"), self.isBundle, "boolean"),
            (_q("isServiceEnabled"), self.isServiceEnabled, "boolean"),
            (_q("isStateful"), self.isStateful, "boolean"),
            (_q("name"), self.name, "string"),
            (_q("serviceDate"), self.serviceDate, "string"),
            (_q("serviceType"), self.serviceType, "string"),
            (_q("startDate"), self.startDate, "string"),
            (_q("startMode"), self.startMode, "string"),
            (_q("state"), self.state, "string"),
            (_q("baseType"), self.baseType, "string"),
            (_q("schemaLocation"), self.schemaLocation, "string"),
            (_q("type"), self.type, "string")
        ])

        elements[_q("feature")] = yang.gdata.List([_q("id")], [f.to_gdata() for f in self.feature])
        elements[_q("note")] = yang.gdata.List([_q("id")], [n.to_gdata() for n in self.note])
        elements[_q("place")] = yang.gdata.List([_q("id")], [p.to_gdata() for p in self.place])
        elements[_q("relatedEntity")] = yang.gdata.List([_q("id")], [re.to_gdata() for re in self.relatedEntity])
        elements[_q("relatedParty")] = yang.gdata.List([_q("id")], [rp.to_gdata() for rp in self.relatedParty])
        elements[_q("serviceCharacteristic")] = yang.gdata.List([_q("name")], [sc.to_gdata() for sc in self.serviceCharacteristic])
        elements[_q("serviceOrderItem")] = yang.gdata.List([_q("id")], [so.to_gdata() for so in self.serviceOrderItem])
        elements[_q("serviceRelationship")] = yang.gdata.List([_q("id")], [sr.to_gdata() for sr in self.serviceRelationship])
        elements[_q("serviceSpecification")] = self.serviceSpecification.to_gdata()
        elements[_q("supportingResource")] = yang.gdata.List([_q("id")], [sr.to_gdata() for sr in self.supportingResource])
        elements[_q("supportingService")] = yang.gdata.List([_q("id")], [ss.to_gdata() for ss in self.supportingService])

        return yang.gdata.Container(elements)

class ConstraintRef(object):
    id: ?str
    href: ?str
    name: ?str
    version: ?str
    baseType: ?str
    schemaLocation: ?str
    type: ?str
    referredType: ?str

    def __init__(self, id: ?str, href: ?str, name: ?str, version: ?str, baseType: ?str, schemaLocation: ?str, type: ?str, referredType: ?str):
        self.id = id
        self.href = href
        self.name = name
        self.version = version
        self.baseType = baseType if baseType is not None else "ConstraintRef"
        self.schemaLocation = schemaLocation if schemaLocation is not None else "/tmf-api/schema/Service/ConstraintRef.schema.json"
        self.type = type if type is not None else "ConstraintRef"
        self.referredType = referredType if referredType is not None else "Constraint"

    @staticmethod
    def from_json(data: dict[str, ?value]) -> ConstraintRef:
        return ConstraintRef(
            get_opt_str(data, "id"),
            get_opt_str(data, "href"),
            get_opt_str(data, "name"),
            get_opt_str(data, "version"),
            get_opt_str(data, "@baseType"),
            get_opt_str(data, "@schemaLocation"),
            get_opt_str(data, "@type"),
            get_opt_str(data, "@referredType")
        )

    def to_json(self) -> dict[str, ?value]:
        return {
            "id": self.id,
            "href": self.href,
            "name": self.name,
            "version": self.version,
            "@baseType": self.baseType,
            "@schemaLocation": self.schemaLocation,
            "@type": self.type,
            "@referredType": self.referredType
        }

    @staticmethod
    def from_gdata(gd: yang.gdata.Node) -> ConstraintRef:
        if isinstance(gd, yang.gdata.Container):
            return ConstraintRef(
                get_opt_child_str(gd, _q("id")),
                get_opt_child_str(gd, _q("href")),
                get_opt_child_str(gd, _q("name")),
                get_opt_child_str(gd, _q("version")),
                get_opt_child_str(gd, _q("baseType")),
                get_opt_child_str(gd, _q("schemaLocation")),
                get_opt_child_str(gd, _q("type")),
                get_opt_child_str(gd, _q("referredType"))
            )
        raise ValueError("Unsupported gdata node type")

    def to_gdata(self) -> yang.gdata.Node:
        elements = {}
        add_leafs_to_gdata(elements, [
            (_q("id"), self.id, "string")
        ])
        add_opt_leafs_to_gdata(elements, [
            (_q("href"), self.href, "string"),
            (_q("name"), self.name, "string"),
            (_q("version"), self.version, "string"),
            (_q("baseType"), self.baseType, "string"),
            (_q("schemaLocation"), self.schemaLocation, "string"),
            (_q("type"), self.type, "string"),
            (_q("referredType"), self.referredType, "string")
        ])

        return yang.gdata.Container(elements)

class FeatureRelationship(object):
    id: ?str
    name: ?str
    relationshipType: ?str
    validFor: ?TimePeriod
    baseType: ?str
    schemaLocation: ?str
    type: ?str

    def __init__(self, id: ?str, name: ?str, relationshipType: ?str, validFor: ?TimePeriod, baseType: ?str, schemaLocation: ?str, type: ?str):
        self.id = id
        self.name = name
        self.relationshipType = relationshipType
        self.validFor = validFor
        self.baseType = baseType if baseType is not None else "FeatureRelationship"
        self.schemaLocation = schemaLocation if schemaLocation is not None else "/tmf-api/schema/Service/FeatureRelationship.schema.json"
        self.type = type if type is not None else "FeatureRelationship"

    @staticmethod
    def from_json(data: dict[str, ?value]) -> FeatureRelationship:
        return FeatureRelationship(
            get_opt_str(data, "id"),
            get_opt_str(data, "name"),
            get_opt_str(data, "relationshipType"),
            get_opt_time_period(data, "validFor"),
            get_opt_str(data, "@baseType"),
            get_opt_str(data, "@schemaLocation"),
            get_opt_str(data, "@type")
        )

    def to_json(self) -> dict[str, ?value]:
        return {
            "id": self.id,
            "name": self.name,
            "relationshipType": self.relationshipType,
            "validFor": get_opt_obj_to_json(self.validFor),
            "@baseType": self.baseType,
            "@schemaLocation": self.schemaLocation,
            "@type": self.type
        }

    @staticmethod
    def from_gdata(gd: yang.gdata.Node) -> FeatureRelationship:
        if isinstance(gd, yang.gdata.Container):
            return FeatureRelationship(
                get_opt_child_str(gd, _q("id")),
                get_opt_child_str(gd, _q("name")),
                get_opt_child_str(gd, _q("relationshipType")),
                get_opt_child_time_period(gd, _q("validFor")),
                get_opt_child_str(gd, _q("baseType")),
                get_opt_child_str(gd, _q("schemaLocation")),
                get_opt_child_str(gd, _q("type"))
            )
        raise ValueError("Unsupported gdata node type")

    def to_gdata(self) -> yang.gdata.Node:
        elements = {}
        add_leafs_to_gdata(elements, [
            (_q("id"), self.id, "string")
        ])
        add_opt_leafs_to_gdata(elements, [
            (_q("name"), self.name, "string"),
            (_q("relationshipType"), self.relationshipType, "string"),
            (_q("baseType"), self.baseType, "string"),
            (_q("schemaLocation"), self.schemaLocation, "string"),
            (_q("type"), self.type, "string")
        ])
        add_opt_obj_to_gdata(elements, _q("validFor"), self.validFor)

        return yang.gdata.Container(elements)

class TimePeriod(object):
    endDateTime: ?str
    startDateTime: ?str
    baseType: ?str
    schemaLocation: ?str
    type: ?str

    def __init__(self, endDateTime: ?str, startDateTime: ?str, baseType: ?str, schemaLocation: ?str, type: ?str):
        self.endDateTime = endDateTime
        self.startDateTime = startDateTime
        self.baseType = baseType if baseType is not None else "TimePeriod"
        self.schemaLocation = schemaLocation if schemaLocation is not None else "/tmf-api/schema/Service/TimePeriod.schema.json"
        self.type = type if type is not None else "TimePeriod"

    @staticmethod
    def from_json(data: dict[str, ?value]) -> TimePeriod:
        return TimePeriod(
            get_opt_str(data, "endDateTime"),
            get_opt_str(data, "startDateTime"),
            get_opt_str(data, "@baseType"),
            get_opt_str(data, "@schemaLocation"),
            get_opt_str(data, "@type")
        )

    def to_json(self) -> dict[str, ?value]:
        return {
            "endDateTime": self.endDateTime,
            "startDateTime": self.startDateTime,
            "@baseType": self.baseType,
            "@schemaLocation": self.schemaLocation,
            "@type": self.type
        }

    @staticmethod
    def from_gdata(gd: yang.gdata.Node) -> TimePeriod:
        if isinstance(gd, yang.gdata.Container):
            return TimePeriod(
                get_opt_child_str(gd, _q("endDateTime")),
                get_opt_child_str(gd, _q("startDateTime")),
                get_opt_child_str(gd, _q("baseType")),
                get_opt_child_str(gd, _q("schemaLocation")),
                get_opt_child_str(gd, _q("type"))
            )
        raise ValueError("Unsupported gdata node type")

    def to_gdata(self) -> yang.gdata.Node:
        elements = {}
        add_opt_leafs_to_gdata(elements, [
            (_q("endDateTime"), self.endDateTime, "string"),
            (_q("startDateTime"), self.startDateTime, "string"),
            (_q("baseType"), self.baseType, "string"),
            (_q("schemaLocation"), self.schemaLocation, "string"),
            (_q("type"), self.type, "string")
        ])

        return yang.gdata.Container(elements)

class Feature(object):
    id: ?str
    isBundle: ?bool
    isEnabled: ?bool
    name: ?str
    constraint: list[ConstraintRef]
    featureCharacteristic: list[Characteristic]
    featureRelationship: list[FeatureRelationship]
    baseType: ?str
    schemaLocation: ?str
    type: ?str

    def __init__(self, id: ?str, isBundle: ?bool, isEnabled: ?bool, name: ?str, constraint: list[ConstraintRef], featureCharacteristic: list[Characteristic], featureRelationship: list[FeatureRelationship], baseType: ?str, schemaLocation: ?str, type: ?str):
        self.id = id
        self.isBundle = isBundle
        self.isEnabled = isEnabled
        self.name = name
        self.constraint = constraint
        self.featureCharacteristic = featureCharacteristic
        self.featureRelationship = featureRelationship
        self.baseType = baseType if baseType is not None else "Feature"
        self.schemaLocation = schemaLocation if schemaLocation is not None else "/tmf-api/schema/Service/Feature.schema.json"
        self.type = type if type is not None else "Feature"

    @staticmethod
    def from_json(data: dict[str, ?value]) -> Feature:
        return Feature(
            get_opt_str(data, "id"),
            get_opt_bool(data, "isBundle"),
            get_opt_bool(data, "isEnabled"),
            get_opt_str(data, "name"),
            list(map(ConstraintRef.from_json, get_list(data.get("constraint")))),
            list(map(Characteristic.from_json, get_list(data.get("featureCharacteristic")))),
            list(map(FeatureRelationship.from_json, get_list(data.get("featureRelationship")))),
            get_opt_str(data, "@baseType"),
            get_opt_str(data, "@schemaLocation"),
            get_opt_str(data, "@type")
        )

    def to_json(self) -> dict[str, ?value]:
        return {
            "id": self.id,
            "isBundle": self.isBundle,
            "isEnabled": self.isEnabled,
            "name": self.name,
            "constraint": [c.to_json() for c in self.constraint],
            "featureCharacteristic": [fc.to_json() for fc in self.featureCharacteristic],
            "featureRelationship": [fr.to_json() for fr in self.featureRelationship],
            "@baseType": self.baseType,
            "@schemaLocation": self.schemaLocation,
            "@type": self.type
        }

    @staticmethod
    def from_gdata(gd: yang.gdata.Node) -> Feature:
        if isinstance(gd, yang.gdata.Container):
            return Feature(
                get_opt_child_str(gd, _q("id")),
                get_opt_child_bool(gd, _q("isBundle")),
                get_opt_child_bool(gd, _q("isEnabled")),
                get_opt_child_str(gd, _q("name")),
                list(map(ConstraintRef.from_gdata, get_yang_list_elements(gd.children.get(_q("constraint"))))),
                list(map(Characteristic.from_gdata, get_yang_list_elements(gd.children.get(_q("featureCharacteristic"))))),
                list(map(FeatureRelationship.from_gdata, get_yang_list_elements(gd.children.get(_q("featureRelationship"))))),
                get_opt_child_str(gd, _q("baseType")),
                get_opt_child_str(gd, _q("schemaLocation")),
                get_opt_child_str(gd, _q("type"))
            )
        raise ValueError("Unsupported gdata node type")

    def to_gdata(self) -> yang.gdata.Node:
        elements = {}
        add_leafs_to_gdata(elements, [
            (_q("id"), self.id, "string")
        ])
        add_opt_leafs_to_gdata(elements, [
            (_q("isBundle"), self.isBundle, "boolean"),
            (_q("isEnabled"), self.isEnabled, "boolean"),
            (_q("name"), self.name, "string"),
            (_q("baseType"), self.baseType, "string"),
            (_q("schemaLocation"), self.schemaLocation, "string"),
            (_q("type"), self.type, "string")
        ])

        elements[_q("constraint")] = yang.gdata.List([_q("id")], [c.to_gdata() for c in self.constraint])
        elements[_q("featureCharacteristic")] = yang.gdata.List([_q("name")], [fc.to_gdata() for fc in self.featureCharacteristic])
        elements[_q("featureRelationship")] = yang.gdata.List([_q("id")], [fr.to_gdata() for fr in self.featureRelationship])

        return yang.gdata.Container(elements)

class Note(object):
    id: ?str
    author: ?str
    date: ?str
    text: ?str
    baseType: ?str
    schemaLocation: ?str
    type: ?str

    def __init__(self, id: ?str, author: ?str, date: ?str, text: ?str, baseType: ?str, schemaLocation: ?str, type: ?str):
        self.id = id
        self.author = author
        self.date = date
        self.text = text
        self.baseType = baseType if baseType is not None else "Note"
        self.schemaLocation = schemaLocation if schemaLocation is not None else "/tmf-api/schema/Service/Note.schema.json"
        self.type = type if type is not None else "Note"

    @staticmethod
    def from_json(data: dict[str, ?value]) -> Note:
        return Note(
            get_opt_str(data, "id"),
            get_opt_str(data, "author"),
            get_opt_str(data, "date"),
            get_opt_str(data, "text"),
            get_opt_str(data, "@baseType"),
            get_opt_str(data, "@schemaLocation"),
            get_opt_str(data, "@type")
        )

    def to_json(self) -> dict[str, ?value]:
        return {
            "id": self.id,
            "author": self.author,
            "date": self.date,
            "text": self.text,
            "@baseType": self.baseType,
            "@schemaLocation": self.schemaLocation,
            "@type": self.type
        }

    @staticmethod
    def from_gdata(gd: yang.gdata.Node) -> Note:
        if isinstance(gd, yang.gdata.Container):
            return Note(
                get_opt_child_str(gd, _q("id")),
                get_opt_child_str(gd, _q("author")),
                get_opt_child_str(gd, _q("date")),
                get_opt_child_str(gd, _q("text")),
                get_opt_child_str(gd, _q("baseType")),
                get_opt_child_str(gd, _q("schemaLocation")),
                get_opt_child_str(gd, _q("type"))
            )
        raise ValueError("Unsupported gdata node type")

    def to_gdata(self) -> yang.gdata.Node:
        elements = {}
        add_leafs_to_gdata(elements, [
            (_q("id"), self.id, "string"),
        ])
        add_opt_leafs_to_gdata(elements, [
            (_q("author"), self.author, "string"),
            (_q("date"), self.date, "string"),
            (_q("text"), self.text, "string"),
            (_q("baseType"), self.baseType, "string"),
            (_q("schemaLocation"), self.schemaLocation, "string"),
            (_q("type"), self.type, "string")
        ])

        return yang.gdata.Container(elements)

class RelatedPlaceRefOrValue(object):
    id: ?str
    href: ?str
    name: ?str
    role: ?str
    baseType: ?str
    schemaLocation: ?str
    type: ?str
    referredType: ?str

    def __init__(self, id: ?str, href: ?str, name: ?str, role: ?str, baseType: ?str, schemaLocation: ?str, type: ?str, referredType: ?str):
        self.id = id
        self.href = href
        self.name = name
        self.role = role
        self.baseType = baseType if baseType is not None else "RelatedPlaceRefOrValue"
        self.schemaLocation = schemaLocation if schemaLocation is not None else "/tmf-api/schema/Service/RelatedPlaceRefOrValue.schema.json"
        self.type = type if type is not None else "RelatedPlaceRefOrValue"
        self.referredType = referredType if referredType is not None else "Place"

    @staticmethod
    def from_json(data: dict[str, ?value]) -> RelatedPlaceRefOrValue:
        return RelatedPlaceRefOrValue(
            get_opt_str(data, "id"),
            get_opt_str(data, "href"),
            get_opt_str(data, "name"),
            get_opt_str(data, "role"),
            get_opt_str(data, "@baseType"),
            get_opt_str(data, "@schemaLocation"),
            get_opt_str(data, "@type"),
            get_opt_str(data, "@referredType")
        )

    def to_json(self) -> dict[str, ?value]:
        return {
            "id": self.id,
            "href": self.href,
            "name": self.name,
            "role": self.role,
            "@baseType": self.baseType,
            "@schemaLocation": self.schemaLocation,
            "@type": self.type,
            "@referredType": self.referredType
        }

    @staticmethod
    def from_gdata(gd: yang.gdata.Node) -> RelatedPlaceRefOrValue:
        if isinstance(gd, yang.gdata.Container):
            return RelatedPlaceRefOrValue(
                get_opt_child_str(gd, _q("id")),
                get_opt_child_str(gd, _q("href")),
                get_opt_child_str(gd, _q("name")),
                get_opt_child_str(gd, _q("role")),
                get_opt_child_str(gd, _q("baseType")),
                get_opt_child_str(gd, _q("schemaLocation")),
                get_opt_child_str(gd, _q("type")),
                get_opt_child_str(gd, _q("referredType"))
            )
        raise ValueError("Unsupported gdata node type")

    def to_gdata(self) -> yang.gdata.Node:
        elements = {}
        add_leafs_to_gdata(elements, [
            (_q("id"), self.id, "string")
        ])
        add_opt_leafs_to_gdata(elements, [
            (_q("href"), self.href, "string"),
            (_q("name"), self.name, "string"),
            (_q("role"), self.role, "string"),
            (_q("baseType"), self.baseType, "string"),
            (_q("schemaLocation"), self.schemaLocation, "string"),
            (_q("type"), self.type, "string"),
            (_q("referredType"), self.referredType, "string")
        ])

        return yang.gdata.Container(elements)

class RelatedEntityRefOrValue(object):
    id: ?str
    href: ?str
    name: ?str
    role: ?str
    baseType: ?str
    schemaLocation: ?str
    type: ?str
    referredType: ?str

    def __init__(self, id: ?str, href: ?str, name: ?str, role: ?str, baseType: ?str, schemaLocation: ?str, type: ?str, referredType: ?str):
        self.id = id
        self.href = href
        self.name = name
        self.role = role
        self.baseType = baseType if baseType is not None else "RelatedEntityRefOrValue"
        self.schemaLocation = schemaLocation if schemaLocation is not None else "/tmf-api/schema/Service/RelatedEntityRefOrValue.schema.json"
        self.type = type if type is not None else "RelatedEntityRefOrValue"
        self.referredType = referredType if referredType is not None else "Entity"

    @staticmethod
    def from_json(data: dict[str, ?value]) -> RelatedEntityRefOrValue:
        return RelatedEntityRefOrValue(
            get_opt_str(data, "id"),
            get_opt_str(data, "href"),
            get_opt_str(data, "name"),
            get_opt_str(data, "role"),
            get_opt_str(data, "@baseType"),
            get_opt_str(data, "@schemaLocation"),
            get_opt_str(data, "@type"),
            get_opt_str(data, "@referredType")
        )

    def to_json(self) -> dict[str, ?value]:
        return {
            "id": self.id,
            "href": self.href,
            "name": self.name,
            "role": self.role,
            "@baseType": self.baseType,
            "@schemaLocation": self.schemaLocation,
            "@type": self.type,
            "@referredType": self.referredType
        }

    @staticmethod
    def from_gdata(gd: yang.gdata.Node) -> RelatedEntityRefOrValue:
        if isinstance(gd, yang.gdata.Container):
            return RelatedEntityRefOrValue(
                get_opt_child_str(gd, _q("id")),
                get_opt_child_str(gd, _q("href")),
                get_opt_child_str(gd, _q("name")),
                get_opt_child_str(gd, _q("role")),
                get_opt_child_str(gd, _q("baseType")),
                get_opt_child_str(gd, _q("schemaLocation")),
                get_opt_child_str(gd, _q("type")),
                get_opt_child_str(gd, _q("referredType"))
            )
        raise ValueError("Unsupported gdata node type")

    def to_gdata(self) -> yang.gdata.Node:
        elements = {}
        add_leafs_to_gdata(elements, [
            (_q("id"), self.id, "string")
        ])
        add_opt_leafs_to_gdata(elements, [
            (_q("href"), self.href, "string"),
            (_q("name"), self.name, "string"),
            (_q("role"), self.role, "string"),
            (_q("baseType"), self.baseType, "string"),
            (_q("schemaLocation"), self.schemaLocation, "string"),
            (_q("type"), self.type, "string"),
            (_q("referredType"), self.referredType, "string")
        ])

        return yang.gdata.Container(elements)

class RelatedParty(object):
    id: ?str
    href: ?str
    name: ?str
    role: ?str
    baseType: ?str
    schemaLocation: ?str
    type: ?str
    referredType: ?str

    def __init__(self, id: ?str, href: ?str, name: ?str, role: ?str, baseType: ?str, schemaLocation: ?str, type: ?str, referredType: ?str):
        self.id = id
        self.href = href
        self.name = name
        self.role = role
        self.baseType = baseType if baseType is not None else "RelatedParty"
        self.schemaLocation = schemaLocation if schemaLocation is not None else "/tmf-api/schema/Service/RelatedParty.schema.json"
        self.type = type if type is not None else "RelatedParty"
        self.referredType = referredType if referredType is not None else "Party"

    @staticmethod
    def from_json(data: dict[str, ?value]) -> RelatedParty:
        return RelatedParty(
            get_opt_str(data, "id"),
            get_opt_str(data, "href"),
            get_opt_str(data, "name"),
            get_opt_str(data, "role"),
            get_opt_str(data, "@baseType"),
            get_opt_str(data, "@schemaLocation"),
            get_opt_str(data, "@type"),
            get_opt_str(data, "@referredType")
        )

    def to_json(self) -> dict[str, ?value]:
        return {
            "id": self.id,
            "href": self.href,
            "name": self.name,
            "role": self.role,
            "@baseType": self.baseType,
            "@schemaLocation": self.schemaLocation,
            "@type": self.type,
            "@referredType": self.referredType
        }

    @staticmethod
    def from_gdata(gd: yang.gdata.Node) -> RelatedParty:
        if isinstance(gd, yang.gdata.Container):
            return RelatedParty(
                get_opt_child_str(gd, _q("id")),
                get_opt_child_str(gd, _q("href")),
                get_opt_child_str(gd, _q("name")),
                get_opt_child_str(gd, _q("role")),
                get_opt_child_str(gd, _q("baseType")),
                get_opt_child_str(gd, _q("schemaLocation")),
                get_opt_child_str(gd, _q("type")),
                get_opt_child_str(gd, _q("referredType"))
            )
        raise ValueError("Unsupported gdata node type")

    def to_gdata(self) -> yang.gdata.Node:
        elements = {}
        add_leafs_to_gdata(elements, [
            (_q("id"), self.id, "string")
        ])
        add_opt_leafs_to_gdata(elements, [
            (_q("href"), self.href, "string"),
            (_q("name"), self.name, "string"),
            (_q("role"), self.role, "string"),
            (_q("baseType"), self.baseType, "string"),
            (_q("schemaLocation"), self.schemaLocation, "string"),
            (_q("type"), self.type, "string"),
            (_q("referredType"), self.referredType, "string")
        ])

        return yang.gdata.Container(elements)

class Characteristic(object):
    id: str
    name: str
    valueType: ?str
    characteristicRelationship: list[CharacteristicRelationship]
    value: ?value
    baseType: ?str
    schemaLocation: ?str
    type: ?str

    def __init__(self, id: str, name: str, valueType: ?str, characteristicRelationship: list[CharacteristicRelationship], value: ?value, baseType: ?str, schemaLocation: ?str, type: ?str):
        self.id = id
        self.name = name
        self.valueType = valueType
        self.characteristicRelationship = characteristicRelationship
        self.value = value
        self.baseType = baseType if baseType is not None else "Characteristic"
        self.schemaLocation = schemaLocation if schemaLocation is not None else "/tmf-api/schema/Service/Characteristic.schema.json"
        self.type = type if type is not None else "Characteristic"

    @staticmethod
    def from_json(data: dict[str, ?value]) -> Characteristic:
        return Characteristic(
            get_str(data, "id"),
            get_str(data, "name"),
            get_opt_str(data, "valueType"),
            list(map(CharacteristicRelationship.from_json, get_list(data.get("characteristicRelationship")))),
            get_opt_value(data, "value"),
            get_opt_str(data, "@baseType"),
            get_opt_str(data, "@schemaLocation"),
            get_opt_str(data, "@type")
        )

    def to_json(self) -> dict[str, ?value]:
        return {
            "id": self.id,
            "name": self.name,
            "valueType": self.valueType,
            "characteristicRelationship": [cr.to_json() for cr in self.characteristicRelationship],
            "value": self.value,
            "@baseType": self.baseType,
            "@schemaLocation": self.schemaLocation,
            "@type": self.type
        }

    @staticmethod
    def from_gdata(gd: yang.gdata.Node) -> Characteristic:
        if isinstance(gd, yang.gdata.Container):
            return Characteristic(
                get_child_str(gd, _q("id")),
                get_child_str(gd, _q("name")),
                None,  # The valueType is derived from the value on the destination leaf
                list(map(CharacteristicRelationship.from_gdata, get_yang_list_elements(gd.children.get(_q("characteristicRelationship"))))),
                None,   # The value is stored on the destination leaf
                get_opt_child_str(gd, _q("baseType")),
                get_opt_child_str(gd, _q("schemaLocation")),
                get_opt_child_str(gd, _q("type"))
            )
        raise ValueError("Unsupported gdata node type")

    def to_gdata(self) -> yang.gdata.Node:
        elements = {}
        add_leafs_to_gdata(elements, [
            (_q("id"), self.id, "string"),
            (_q("name"), self.name, "string")
        ])
        add_opt_leafs_to_gdata(elements, [
            # NOTE: The value and valueType are not stored in the TMF Store
            # because they are stored on the respective leaf
            # of the destination transform.
            (_q("baseType"), self.baseType, "string"),
            (_q("schemaLocation"), self.schemaLocation, "string"),
            (_q("type"), self.type, "string")
        ])

        elements[_q("characteristicRelationship")] = yang.gdata.List([_q("id")], [cr.to_gdata() for cr in self.characteristicRelationship])

        return yang.gdata.Container(elements)

class CharacteristicRelationship(object):
    id: ?str
    relationshipType: ?str
    baseType: ?str
    schemaLocation: ?str
    type: ?str

    def __init__(self, id: ?str, relationshipType: ?str, baseType: ?str, schemaLocation: ?str, type: ?str):
        self.id = id
        self.relationshipType = relationshipType
        self.baseType = baseType if baseType is not None else "CharacteristicRelationship"
        self.schemaLocation = schemaLocation if schemaLocation is not None else "/tmf-api/schema/Service/CharacteristicRelationship.schema.json"
        self.type = type if type is not None else "CharacteristicRelationship"

    @staticmethod
    def from_json(data: dict[str, ?value]) -> CharacteristicRelationship:
        return CharacteristicRelationship(
            get_opt_str(data, "id"),
            get_opt_str(data, "relationshipType"),
            get_opt_str(data, "@baseType"),
            get_opt_str(data, "@schemaLocation"),
            get_opt_str(data, "@type")
        )

    def to_json(self) -> dict[str, ?value]:
        return {
            "id": self.id,
            "relationshipType": self.relationshipType,
            "@baseType": self.baseType,
            "@schemaLocation": self.schemaLocation,
            "@type": self.type
        }

    @staticmethod
    def from_gdata(gd: yang.gdata.Node) -> CharacteristicRelationship:
        if isinstance(gd, yang.gdata.Container):
            return CharacteristicRelationship(
                get_opt_child_str(gd, _q("id")),
                get_opt_child_str(gd, _q("relationshipType")),
                get_opt_child_str(gd, _q("baseType")),
                get_opt_child_str(gd, _q("schemaLocation")),
                get_opt_child_str(gd, _q("type"))
            )
        raise ValueError("Unsupported gdata node type")

    def to_gdata(self) -> yang.gdata.Node:
        elements = {}
        add_leafs_to_gdata(elements, [
            (_q("id"), self.id, "string")
        ])
        add_opt_leafs_to_gdata(elements, [
            (_q("relationshipType"), self.relationshipType, "string"),
            (_q("baseType"), self.baseType, "string"),
            (_q("schemaLocation"), self.schemaLocation, "string"),
            (_q("type"), self.type, "string")
        ])

        return yang.gdata.Container(elements)

class ServiceSpecificationRef(object):
    id: str
    href: ?str
    name: ?str
    version: ?str
    baseType: ?str
    schemaLocation: ?str
    type: ?str
    referredType: ?str

    def __init__(self, id: str, href: ?str, name: ?str, version: ?str, baseType: ?str, schemaLocation: ?str, type: ?str, referredType: ?str):
        self.id = id
        self.href = href
        self.name = name
        self.version = version
        self.baseType = baseType if baseType is not None else "ServiceSpecificationRef"
        self.schemaLocation = schemaLocation if schemaLocation is not None else "/tmf-api/schema/Service/ServiceSpecificationRef.schema.json"
        self.type = type if type is not None else "ServiceSpecificationRef"
        self.referredType = referredType if referredType is not None else "ServiceSpecification"

    @staticmethod
    def from_json(data: dict[str, ?value]) -> ServiceSpecificationRef:
        return ServiceSpecificationRef(
            get_str(data, "id"),
            get_opt_str(data, "href"),
            get_opt_str(data, "name"),
            get_opt_str(data, "version"),
            get_opt_str(data, "@baseType"),
            get_opt_str(data, "@schemaLocation"),
            get_opt_str(data, "@type"),
            get_opt_str(data, "@referredType")
        )

    def to_json(self) -> dict[str, ?value]:
        return {
            "id": self.id,
            "href": self.href,
            "name": self.name,
            "version": self.version,
            "@baseType": self.baseType,
            "@schemaLocation": self.schemaLocation,
            "@type": self.type,
            "@referredType": self.referredType
        }

    @staticmethod
    def from_gdata(gd: yang.gdata.Node) -> ServiceSpecificationRef:
        if isinstance(gd, yang.gdata.Container):
            return ServiceSpecificationRef(
                get_child_str(gd, _q("id")),
                get_opt_child_str(gd, _q("href")),
                get_opt_child_str(gd, _q("name")),
                get_opt_child_str(gd, _q("version")),
                get_opt_child_str(gd, _q("baseType")),
                get_opt_child_str(gd, _q("schemaLocation")),
                get_opt_child_str(gd, _q("type")),
                get_opt_child_str(gd, _q("referredType"))
            )
        raise ValueError("Unsupported gdata node type")

    def to_gdata(self) -> yang.gdata.Node:
        elements = {}
        add_leafs_to_gdata(elements, [
            (_q("id"), self.id, "string")
        ])
        add_opt_leafs_to_gdata(elements, [
            (_q("href"), self.href, "string"),
            (_q("name"), self.name, "string"),
            (_q("version"), self.version, "string"),
            (_q("baseType"), self.baseType, "string"),
            (_q("schemaLocation"), self.schemaLocation, "string"),
            (_q("type"), self.type, "string"),
            (_q("referredType"), self.referredType, "string")
        ])

        return yang.gdata.Container(elements)

class ResourceRef(object):
    id: ?str
    href: ?str
    name: ?str
    baseType: ?str
    schemaLocation: ?str
    type: ?str
    referredType: ?str

    def __init__(self, id: ?str, href: ?str, name: ?str, baseType: ?str, schemaLocation: ?str, type: ?str, referredType: ?str):
        self.id = id
        self.href = href
        self.name = name
        self.baseType = baseType if baseType is not None else "ResourceRef"
        self.schemaLocation = schemaLocation if schemaLocation is not None else "/tmf-api/schema/Service/ResourceRef.schema.json"
        self.type = type if type is not None else "ResourceRef"
        self.referredType = referredType if referredType is not None else "Resource"

    @staticmethod
    def from_json(data: dict[str, ?value]) -> ResourceRef:
        return ResourceRef(
            get_opt_str(data, "id"),
            get_opt_str(data, "href"),
            get_opt_str(data, "name"),
            get_opt_str(data, "@baseType"),
            get_opt_str(data, "@schemaLocation"),
            get_opt_str(data, "@type"),
            get_opt_str(data, "@referredType")
        )

    def to_json(self) -> dict[str, ?value]:
        return {
            "id": self.id,
            "href": self.href,
            "name": self.name,
            "@baseType": self.baseType,
            "@schemaLocation": self.schemaLocation,
            "@type": self.type,
            "@referredType": self.referredType
        }

    @staticmethod
    def from_gdata(gd: yang.gdata.Node) -> ResourceRef:
        if isinstance(gd, yang.gdata.Container):
            return ResourceRef(
                get_child_str(gd, _q("id")),
                get_opt_child_str(gd, _q("href")),
                get_opt_child_str(gd, _q("name")),
                get_opt_child_str(gd, _q("baseType")),
                get_opt_child_str(gd, _q("schemaLocation")),
                get_opt_child_str(gd, _q("type")),
                get_opt_child_str(gd, _q("referredType"))
            )
        raise ValueError("Unsupported gdata node type")

    def to_gdata(self) -> yang.gdata.Node:
        elements = {}
        add_leafs_to_gdata(elements, [
            (_q("id"), self.id, "string")
        ])
        add_opt_leafs_to_gdata(elements, [
            (_q("href"), self.href, "string"),
            (_q("name"), self.name, "string"),
            (_q("baseType"), self.baseType, "string"),
            (_q("schemaLocation"), self.schemaLocation, "string"),
            (_q("type"), self.type, "string"),
            (_q("referredType"), self.referredType, "string")
        ])

        return yang.gdata.Container(elements)


class RelatedServiceOrderItem(object):
    itemId: ?str
    role: ?str
    serviceOrderHref: ?str
    serviceOrderId: ?str
    itemAction: ?str
    baseType: ?str
    schemaLocation: ?str
    type: ?str
    referredType: ?str

    def __init__(self, itemId: ?str, role: ?str, serviceOrderHref: ?str, serviceOrderId: ?str, itemAction: ?str, baseType: ?str, schemaLocation: ?str, type: ?str, referredType: ?str):
        self.itemId = itemId
        self.role = role
        self.serviceOrderHref = serviceOrderHref
        self.serviceOrderId = serviceOrderId
        self.itemAction = itemAction
        self.baseType = baseType if baseType is not None else "RelatedServiceOrderItem"
        self.schemaLocation = schemaLocation if schemaLocation is not None else "/tmf-api/schema/Service/RelatedServiceOrderItem.schema.json"
        self.type = type if type is not None else "RelatedServiceOrderItem"
        self.referredType = referredType if referredType is not None else "ServiceOrderItem"

    @staticmethod
    def from_json(data: dict[str, ?value]) -> RelatedServiceOrderItem:
        return RelatedServiceOrderItem(
            get_opt_str(data, "itemId"),
            get_opt_str(data, "role"),
            get_opt_str(data, "serviceOrderHref"),
            get_opt_str(data, "serviceOrderId"),
            get_opt_str(data, "itemAction"),
            get_opt_str(data, "@baseType"),
            get_opt_str(data, "@schemaLocation"),
            get_opt_str(data, "@type"),
            get_opt_str(data, "@referredType")
        )

    def to_json(self) -> dict[str, ?value]:
        return {
            "itemId": self.itemId,
            "role": self.role,
            "serviceOrderHref": self.serviceOrderHref,
            "serviceOrderId": self.serviceOrderId,
            "itemAction": self.itemAction,
            "@baseType": self.baseType,
            "@schemaLocation": self.schemaLocation,
            "@type": self.type,
            "@referredType": self.referredType
        }

    @staticmethod
    def from_gdata(gd: yang.gdata.Node) -> RelatedServiceOrderItem:
        if isinstance(gd, yang.gdata.Container):
            return RelatedServiceOrderItem(
                get_opt_child_str(gd, _q("itemId")),
                get_opt_child_str(gd, _q("role")),
                get_opt_child_str(gd, _q("serviceOrderHref")),
                get_opt_child_str(gd, _q("serviceOrderId")),
                get_opt_child_str(gd, _q("itemAction")),
                get_opt_child_str(gd, _q("baseType")),
                get_opt_child_str(gd, _q("schemaLocation")),
                get_opt_child_str(gd, _q("type")),
                get_opt_child_str(gd, _q("referredType"))
            )
        raise ValueError("Unsupported gdata node type")

    def to_gdata(self) -> yang.gdata.Node:
        elements = {}
        add_leafs_to_gdata(elements, [
            (_q("itemId"), self.itemId, "string")
        ])
        add_opt_leafs_to_gdata(elements, [
            (_q("role"), self.role, "string"),
            (_q("serviceOrderHref"), self.serviceOrderHref, "string"),
            (_q("serviceOrderId"), self.serviceOrderId, "string"),
            (_q("itemAction"), self.itemAction, "string"),
            (_q("baseType"), self.baseType, "string"),
            (_q("schemaLocation"), self.schemaLocation, "string"),
            (_q("type"), self.type, "string"),
            (_q("referredType"), self.referredType, "string")
        ])

        return yang.gdata.Container(elements)


class ServiceRelationship(object):
    relationshipType: ?str
    serviceRelationshipCharacteristic: list[Characteristic]
    service: ServiceRefOrValue
    baseType: ?str
    schemaLocation: ?str
    type: ?str

    def __init__(self, relationshipType: ?str, serviceRelationshipCharacteristic: list[Characteristic], service: ServiceRefOrValue, baseType: ?str, schemaLocation: ?str, type: ?str):
        self.relationshipType = relationshipType
        self.serviceRelationshipCharacteristic = serviceRelationshipCharacteristic
        self.service = service
        self.baseType = baseType if baseType is not None else "ServiceRelationship"
        self.schemaLocation = schemaLocation if schemaLocation is not None else "/tmf-api/schema/Service/ServiceRelationship.schema.json"
        self.type = type if type is not None else "ServiceRelationship"

    @staticmethod
    def from_json(data: dict[str, ?value]) -> ServiceRelationship:
        return ServiceRelationship(
            get_opt_str(data, "relationshipType"),
            list(map(Characteristic.from_json, get_list(data.get("serviceRelationshipCharacteristic")))),
            get_service_ref_or_value(data, "service"),
            get_opt_str(data, "@baseType"),
            get_opt_str(data, "@schemaLocation"),
            get_opt_str(data, "@type")
        )

    def to_json(self) -> dict[str, ?value]:
        return {
            "relationshipType": self.relationshipType,
            "serviceRelationshipCharacteristic": [src.to_json() for src in self.serviceRelationshipCharacteristic],
            "service": self.service.to_json(),
            "@baseType": self.baseType,
            "@schemaLocation": self.schemaLocation,
            "@type": self.type
        }

    @staticmethod
    def from_gdata(gd: yang.gdata.Node) -> ServiceRelationship:
        if isinstance(gd, yang.gdata.Container):
            return ServiceRelationship(
                get_opt_child_str(gd, _q("relationshipType")),
                list(map(Characteristic.from_gdata, get_yang_list_elements(gd.children.get(_q("serviceRelationshipCharacteristic"))))),
                get_child_service_ref_or_value(gd, _q("service")),
                get_opt_child_str(gd, _q("baseType")),
                get_opt_child_str(gd, _q("schemaLocation")),
                get_opt_child_str(gd, _q("type"))
            )
        raise ValueError("Unsupported gdata node type")

    def to_gdata(self) -> yang.gdata.Node:
        elements = {}
        add_opt_leafs_to_gdata(elements, [
            (_q("relationshipType"), self.relationshipType, "string"),
            (_q("baseType"), self.baseType, "string"),
            (_q("schemaLocation"), self.schemaLocation, "string"),
            (_q("type"), self.type, "string")
        ])

        elements[_q("serviceRelationshipCharacteristic")] = yang.gdata.List([_q("id")], [src.to_gdata() for src in self.serviceRelationshipCharacteristic])
        elements[_q("service")] = self.service.to_gdata()

        return yang.gdata.Container(elements)

class ServiceRefOrValue(object):
    id: ?str
    href: ?str
    category: ?str
    description: ?str
    endDate: ?str
    hasStarted: ?bool
    isBundle: ?bool
    isServiceEnabled: ?bool
    isStateful: ?bool
    name: ?str
    serviceDate: ?str
    serviceType: ?str
    startDate: ?str
    startMode: ?str
    feature: list[Feature]
    note: list[Note]
    place: list[RelatedPlaceRefOrValue]
    relatedEntity: list[RelatedEntityRefOrValue]
    relatedParty: list[RelatedParty]
    serviceCharacteristic: list[Characteristic]
    serviceOrderItem: list[RelatedServiceOrderItem]
    serviceRelationship: list[ServiceRelationship]
    serviceSpecification: ?ServiceSpecificationRef
    state: ?str
    supportingResource: list[ResourceRef]
    supportingService: list[ServiceRefOrValue]
    baseType: ?str
    schemaLocation: ?str
    type: ?str
    referredType: ?str

    def __init__(self, id: ?str, href: ?str, category: ?str, description: ?str, endDate: ?str, hasStarted: ?bool, isBundle: ?bool, isServiceEnabled: ?bool, isStateful: ?bool, name: ?str, serviceDate: ?str, serviceType: ?str, startDate: ?str, startMode: ?str, feature: list[Feature], note: list[Note], place: list[RelatedPlaceRefOrValue], relatedEntity: list[RelatedEntityRefOrValue], relatedParty: list[RelatedParty], serviceCharacteristic: list[Characteristic], serviceOrderItem: list[RelatedServiceOrderItem], serviceRelationship: list[ServiceRelationship], serviceSpecification: ?ServiceSpecificationRef, state: ?str, supportingResource: list[ResourceRef], supportingService: list[ServiceRefOrValue], baseType: ?str, schemaLocation: ?str, type: ?str, referredType: ?str):
        self.id = id
        self.href = href
        self.category = category
        self.description = description
        self.endDate = endDate
        self.hasStarted = hasStarted
        self.isBundle = isBundle
        self.isServiceEnabled = isServiceEnabled
        self.isStateful = isStateful
        self.name = name
        self.serviceDate = serviceDate
        self.serviceType = serviceType
        self.startDate = startDate
        self.startMode = startMode
        self.feature = feature
        self.note = note
        self.place = place
        self.relatedEntity = relatedEntity
        self.relatedParty = relatedParty
        self.serviceCharacteristic = serviceCharacteristic
        self.serviceOrderItem = serviceOrderItem
        self.serviceRelationship = serviceRelationship
        self.serviceSpecification = serviceSpecification
        self.state = state
        self.supportingResource = supportingResource
        self.supportingService = supportingService
        self.baseType = baseType if baseType is not None else "ServiceRefOrValue"
        self.schemaLocation = schemaLocation if schemaLocation is not None else "/tmf-api/schema/Service/ServiceRefOrValue.schema.json"
        self.type = type if type is not None else "ServiceRefOrValue"
        self.referredType = referredType if referredType is not None else "Service"

    @staticmethod
    def from_json(data: dict[str, ?value]) -> ServiceRefOrValue:

        service_specification = None
        sspec = data.get("serviceSpecification")
        if isinstance(sspec, dict):
            service_specification = ServiceSpecificationRef.from_json(sspec)

        return ServiceRefOrValue(
            get_opt_str(data, "id"),
            get_opt_str(data, "href"),
            get_opt_str(data, "category"),
            get_opt_str(data, "description"),
            get_opt_str(data, "endDate"),
            get_opt_bool(data, "hasStarted"),
            get_opt_bool(data, "isBundle"),
            get_opt_bool(data, "isServiceEnabled"),
            get_opt_bool(data, "isStateful"),
            get_opt_str(data, "name"),
            get_opt_str(data, "serviceDate"),
            get_opt_str(data, "serviceType"),
            get_opt_str(data, "startDate"),
            get_opt_str(data, "startMode"),
            list(map(Feature.from_json, get_list(data.get("feature")))),
            list(map(Note.from_json, get_list(data.get("note")))),
            list(map(RelatedPlaceRefOrValue.from_json, get_list(data.get("place")))),
            list(map(RelatedEntityRefOrValue.from_json, get_list(data.get("relatedEntity")))),
            list(map(RelatedParty.from_json, get_list(data.get("relatedParty")))),
            list(map(Characteristic.from_json, get_list(data.get("serviceCharacteristic")))),
            list(map(RelatedServiceOrderItem.from_json, get_list(data.get("serviceOrderItem")))),
            list(map(ServiceRelationship.from_json, get_list(data.get("serviceRelationship")))),
            service_specification,
            get_opt_str(data, "state"),
            list(map(ResourceRef.from_json, get_list(data.get("supportingResource")))),
            list(map(ServiceRefOrValue.from_json, get_list(data.get("supportingService")))),
            get_opt_str(data, "@baseType"),
            get_opt_str(data, "@schemaLocation"),
            get_opt_str(data, "@type"),
            get_opt_str(data, "@referredType")
        )

    def to_json(self) -> dict[str, ?value]:
        return {
            "id": self.id,
            "href": self.href,
            "category": self.category,
            "description": self.description,
            "endDate": self.endDate,
            "hasStarted": self.hasStarted,
            "isBundle": self.isBundle,
            "isServiceEnabled": self.isServiceEnabled,
            "isStateful": self.isStateful,
            "name": self.name,
            "serviceDate": self.serviceDate,
            "serviceType": self.serviceType,
            "startDate": self.startDate,
            "startMode": self.startMode,
            "feature": [f.to_json() for f in self.feature],
            "note": [n.to_json() for n in self.note],
            "place": [n.to_json() for n in self.place],
            "relatedEntity": [re.to_json() for re in self.relatedEntity],
            "relatedParty": [rp.to_json() for rp in self.relatedParty],
            "serviceCharacteristic": [sc.to_json() for sc in self.serviceCharacteristic],
            "serviceOrderItem": [soi.to_json() for soi in self.serviceOrderItem],
            "serviceRelationship": [sr.to_json() for sr in self.serviceRelationship],
            "serviceSpecification": get_opt_obj_to_json(self.serviceSpecification),
            "state": self.state,
            "supportingResource": [sres.to_json() for sres in self.supportingResource],
            "supportingService": [ss.to_json() for ss in self.supportingService],
            "@baseType": self.baseType,
            "@schemaLocation": self.schemaLocation,
            "@type": self.type,
        }


    @staticmethod
    def from_gdata(gd: yang.gdata.Node) -> ServiceRefOrValue:
        if isinstance(gd, yang.gdata.Container):
            return ServiceRefOrValue(
                get_opt_child_str(gd, _q("id")),
                get_opt_child_str(gd, _q("href")),
                get_opt_child_str(gd, _q("category")),
                get_opt_child_str(gd, _q("description")),
                get_opt_child_str(gd, _q("endDate")),
                get_opt_child_bool(gd, _q("hasStarted")),
                get_opt_child_bool(gd, _q("isBundle")),
                get_opt_child_bool(gd, _q("isServiceEnabled")),
                get_opt_child_bool(gd, _q("isStateful")),
                get_opt_child_str(gd, _q("name")),
                get_opt_child_str(gd, _q("serviceDate")),
                get_opt_child_str(gd, _q("serviceType")),
                get_opt_child_str(gd, _q("startDate")),
                get_opt_child_str(gd, _q("startMode")),
                list(map(Feature.from_gdata, get_yang_list_elements(gd.children.get(_q("feature"))))),
                list(map(Note.from_gdata, get_yang_list_elements(gd.children.get(_q("note"))))),
                list(map(RelatedPlaceRefOrValue.from_gdata, get_yang_list_elements(gd.children.get(_q("place"))))),
                list(map(RelatedEntityRefOrValue.from_gdata, get_yang_list_elements(gd.children.get(_q("relatedEntity"))))),
                list(map(RelatedParty.from_gdata, get_yang_list_elements(gd.children.get(_q("relatedParty"))))),
                list(map(Characteristic.from_gdata, get_yang_list_elements(gd.children.get(_q("serviceCharacteristic"))))),
                list(map(RelatedServiceOrderItem.from_gdata, get_yang_list_elements(gd.children.get(_q("serviceOrderItem"))))),
                list(map(ServiceRelationship.from_gdata, get_yang_list_elements(gd.children.get(_q("serviceRelationship"))))),
                get_child_service_specification_ref(gd, _q("serviceSpecification")),
                get_opt_child_str(gd, _q("state")),
                list(map(ResourceRef.from_gdata, get_yang_list_elements(gd.children.get(_q("supportingResource"))))),
                list(map(ServiceRefOrValue.from_gdata, get_yang_list_elements(gd.children.get(_q("supportingService"))))),
                get_opt_child_str(gd, _q("baseType")),
                get_opt_child_str(gd, _q("schemaLocation")),
                get_opt_child_str(gd, _q("type")),
                get_opt_child_str(gd, _q("referredType"))
            )
        raise ValueError("Unsupported gdata node type")

    def to_gdata(self) -> yang.gdata.Node:
        elements = {}
        add_leafs_to_gdata(elements, [
            (_q("id"), self.id, "string")
        ])
        add_opt_leafs_to_gdata(elements, [
            (_q("href"), self.href, "string"),
            (_q("category"), self.category, "string"),
            (_q("description"), self.description, "string"),
            (_q("endDate"), self.endDate, "string"),
            (_q("hasStarted"), self.hasStarted, "boolean"),
            (_q("isBundle"), self.isBundle, "boolean"),
            (_q("isServiceEnabled"), self.isServiceEnabled, "boolean"),
            (_q("isStateful"), self.isStateful, "boolean"),
            (_q("name"), self.name, "string"),
            (_q("serviceDate"), self.serviceDate, "string"),
            (_q("serviceType"), self.serviceType, "string"),
            (_q("startDate"), self.startDate, "string"),
            (_q("startMode"), self.startMode, "string"),
            (_q("state"), self.state, "string"),
            (_q("baseType"), self.baseType, "string"),
            (_q("schemaLocation"), self.schemaLocation, "string"),
            (_q("type"), self.type, "string")
        ])
        add_opt_obj_to_gdata(elements, _q("serviceSpecification"), self.serviceSpecification)

        elements[_q("feature")] = yang.gdata.List([_q("id")], [f.to_gdata() for f in self.feature])
        elements[_q("note")] = yang.gdata.List([_q("id")], [n.to_gdata() for n in self.note])
        elements[_q("place")] = yang.gdata.List([_q("id")], [p.to_gdata() for p in self.place])
        elements[_q("relatedEntity")] = yang.gdata.List([_q("id")], [re.to_gdata() for re in self.relatedEntity])
        elements[_q("relatedParty")] = yang.gdata.List([_q("id")], [rp.to_gdata() for rp in self.relatedParty])
        elements[_q("serviceCharacteristic")] = yang.gdata.List([_q("id")], [sc.to_gdata() for sc in self.serviceCharacteristic])
        elements[_q("serviceOrderItem")] = yang.gdata.List([_q("itemId")], [soi.to_gdata() for soi in self.serviceOrderItem])
        elements[_q("serviceRelationship")] = yang.gdata.List([_q("id")], [sr.to_gdata() for sr in self.serviceRelationship])
        elements[_q("supportingResource")] = yang.gdata.List([_q("id")], [sres.to_gdata() for sres in self.supportingResource])
        elements[_q("supportingService")] = yang.gdata.List([_q("id")], [ss.to_gdata() for ss in self.supportingService])

        return yang.gdata.Container(elements)

def _test_tmf640_mobile_service():
    test_tmf_payload = {
        "category": "MobileService",
        "description": "Mobile Line ",
        "feature": [
            {
                "id": "1",
                "isBundle": False,
                "isEnabled": True,
                "name": "Voice",
                "featureCharacteristic": [
                    {
                        "id": "1",
                        "name": "VoiceFeatureCharacteristic",
                        "valueType": "object",
                        "value": [
                            {
                                "voiceStandard": "enable",
                                "voWifi": "disable",
                                "roaming": "enable",
                                "@schemaLocation": ".../serviceSpecification/11/featureSpecification/1/VoiceFeatureCharacteristic.json",
                                "@type": "VoiceFeatureCharacteristic"
                            }
                        ],
                        "@type": "FeatureCharacteristic"
                    }
                ],
                "@type": "Feature"
            },
            {
                "id": "2",
                "isEnabled": False,
                "name": "Data",
                "@type": "Feature",
                "featureCharacteristic": [
                    {
                        "id": "75",
                        "name": "isGreen",
                        "valueType": "string",
                        "value": "enable"
                    }
                ]
            },
            {
                "id": "3",
                "isEnabled": True,
                "name": "Messaging",
                "featureCharacteristic": [
                    {
                        "id": "74",
                        "name": "incomingSMS",
                        "valueType": "string",
                        "value": "enable"
                    },
                    {
                        "id": "73",
                        "name": "outgoingSMS",
                        "valueType": "string",
                        "value": "enable"
                    }
                ],
                "@type": "Feature"
            }
        ],
        "relatedParty": [
            {
                "id": "78",
                "name": "TMF Telco",
                "role": "Service Provider",
                "@referredType": "Organization"
            },
            {
                "id": "12",
                "name": "Jean Pontus",
                "role": "user",
                "@referredType": "Individual"
            }
        ],
        "serviceCharacteristic": [
            {
                "id": "89",
                "name": "MSISDN",
                "valueType": "string",
                "value": "415-275-7439"
            }
        ],
        "serviceSpecification": {
            "id": "cfs45",
            "name": "c_Mobile",
            "@type": "serviceSpecification",
            "@referredType": "ServiceSpecification"
        },
        "state": "active",
        "supportingService": [
            {
                "serviceSpecification": {
                    "id": "cfs89",
                    "href": ".../serviceCatalog/v4/serviceSpecification/cfs89",
                    "name": "c_MobileSupport",
                    "@type": "serviceSpecification",
                    "@referredType": "ServiceSpecification"
                },
                "serviceCharacteristic": [
                    {
                        "id": "sd-8",
                        "name": "IMSI",
                        "valueType": "string",
                        "value": "228 01 21 76510739 "
                    }
                ],
                "state": "active",
                "@type": "Service"
            },
            {
                "id": "741-853",
                "href": "http://serverlocation:port/serviceActivationConfiguration/v4/service/741-853",
                "@referredType": "Service",
                "@type": "ServiceRef"
            }
        ],
        "@type": "Service"
    }
    service = Service.from_json(test_tmf_payload)
    testing.assertEqual(service.id, None)
    testing.assertEqual(service.name, None)
    testing.assertEqual(service.category, "MobileService")
    testing.assertEqual(service.description, "Mobile Line ")
    f0 = service.feature[0]
    testing.assertEqual(f0.id, "1")
    testing.assertEqual(f0.isBundle, False)
    testing.assertEqual(f0.isEnabled, True)
    testing.assertEqual(f0.name, "Voice")
    testing.assertEqual(len(f0.featureCharacteristic), 1)
    fc0 = f0.featureCharacteristic[0]
    testing.assertEqual(fc0.id, "1")
    testing.assertEqual(fc0.name, "VoiceFeatureCharacteristic")
    testing.assertEqual(fc0.valueType, "object")
    f1 = service.feature[1]
    testing.assertEqual(f1.id, "2")
    testing.assertEqual(f1.isEnabled, False)
    testing.assertEqual(f1.name, "Data")
    testing.assertEqual(len(f1.featureCharacteristic), 1)
    fc1 = f1.featureCharacteristic[0]
    testing.assertEqual(fc1.id, "75")
    testing.assertEqual(fc1.name, "isGreen")
    testing.assertEqual(fc1.valueType, "string")
    f2 = service.feature[2]
    testing.assertEqual(f2.id, "3")
    testing.assertEqual(f2.isEnabled, True)
    testing.assertEqual(f2.name, "Messaging")
    testing.assertEqual(len(f2.featureCharacteristic), 2)
    fc2_0 = f2.featureCharacteristic[0]
    testing.assertEqual(fc2_0.id, "74")
    testing.assertEqual(fc2_0.name, "incomingSMS")
    testing.assertEqual(fc2_0.valueType, "string")
    fc2_1 = f2.featureCharacteristic[1]
    testing.assertEqual(fc2_1.id, "73")
    testing.assertEqual(fc2_1.name, "outgoingSMS")
    testing.assertEqual(fc2_1.valueType, "string")
    testing.assertEqual(len(service.relatedParty), 2)
    rp0 = service.relatedParty[0]
    testing.assertEqual(rp0.id, "78")
    testing.assertEqual(rp0.name, "TMF Telco")
    testing.assertEqual(rp0.role, "Service Provider")
    testing.assertEqual(rp0.referredType, "Organization")
    rp1 = service.relatedParty[1]
    testing.assertEqual(rp1.id, "12")
    testing.assertEqual(rp1.name, "Jean Pontus")
    testing.assertEqual(rp1.role, "user")
    testing.assertEqual(rp1.referredType, "Individual")
    testing.assertEqual(len(service.serviceCharacteristic), 1)
    testing.assertEqual(service.serviceCharacteristic[0].name, "MSISDN")
    testing.assertEqual(service.serviceCharacteristic[0].valueType, "string")
    sspec = service.serviceSpecification
    if sspec is not None:
        testing.assertEqual(sspec.id, "cfs45")
        testing.assertEqual(sspec.name, "c_Mobile")
        testing.assertEqual(sspec.type, "serviceSpecification")
        testing.assertEqual(sspec.referredType, "ServiceSpecification")
    testing.assertEqual(service.state, "active")
    testing.assertEqual(len(service.supportingService), 2)
    ss0 = service.supportingService[0]
    ss0_sspec = ss0.serviceSpecification
    if ss0_sspec is not None:
        testing.assertEqual(ss0_sspec.id, "cfs89")
        testing.assertEqual(ss0_sspec.href, ".../serviceCatalog/v4/serviceSpecification/cfs89")
        testing.assertEqual(ss0_sspec.name, "c_MobileSupport")
        testing.assertEqual(ss0_sspec.type, "serviceSpecification")
        testing.assertEqual(ss0_sspec.referredType, "ServiceSpecification")
    testing.assertEqual(len(ss0.serviceCharacteristic), 1)
    ss0_sc0 = ss0.serviceCharacteristic[0]
    testing.assertEqual(ss0_sc0.id, "sd-8")
    testing.assertEqual(ss0_sc0.name, "IMSI")
    testing.assertEqual(ss0_sc0.valueType, "string")
    testing.assertEqual(ss0.state, "active")
    ss1 = service.supportingService[1]
    testing.assertEqual(ss1.id, "741-853")
    testing.assertEqual(ss1.href, "http://serverlocation:port/serviceActivationConfiguration/v4/service/741-853")
    testing.assertEqual(ss1.referredType, "Service")
    testing.assertEqual(ss1.type, "ServiceRef")
    testing.assertEqual(service.type, "Service")

def _test_netinfra_router():
    test_tmf_payload = {
        "serviceCharacteristic": [
            {
                "id": "name",
                "name": "name",
                "valueType": "string",
                "value": "ams-core-1"
            }
        ],
        "serviceSpecification": {
            "id": "spec1",
        }
    }

    yang_schema = r"""module test {
    yang-version "1.1";
    namespace "http://example.com/test";
    prefix "tst";

    container netinfra {
        list router {
            key "name";
            leaf name {
                type string;
            }
        }
    }
}
    """

    service = Service.from_json(test_tmf_payload)
    s = yang.compile([yang_schema])
    gd = yang.gen3.from_data(s, service.serviceCharacteristic, root_path=["test:netinfra", "router"])
    r = yang.gdata.Container({
        yang.gdata.Id("http://example.com/test", "netinfra"): yang.gdata.Container({
            yang.gdata.Id("http://example.com/test", "router"): yang.gdata.List(
                [yang.gdata.Id("http://example.com/test", "name")],
                ns='http://example.com/test', module='tst',
                elements=[
                    yang.gdata.Container({
                        yang.gdata.Id("http://example.com/test", "name"): yang.gdata.Leaf('ams-core-1')
                    })
                ])
        }, ns='http://example.com/test', module='tst')
    })
    return r.prsrc()

def _test_characteristic_type_mismatch():
    test_tmf_payload = {
        "serviceCharacteristic": [
            {
                "id": "leaf1",
                "name": "leaf1",
                "valueType": "string",
                "value": "415-275-7439"
            }
        ],
        "serviceSpecification": {
            "id": "spec1",
        }
    }

    yang_schema = r"""module test {
    yang-version "1.1";
    namespace "http://example.com/test";
    prefix "tst";

    leaf leaf1 {
        type int32;
    }
}
    """

    service = Service.from_json(test_tmf_payload)
    s = yang.compile([yang_schema])
    try:
        gd = yang.gen3.from_data(s, service.serviceCharacteristic)
    except yang.gen3.YangValidationError as exc:
        testing.assertEqual("Invalid value at /: '415-275-7439' - expected int32 with range -2147483648..2147483647", str(exc), "Expected YangValidationError")
        return
    testing.error("Expected YangValidationError")

def _test_characteristic_number():
    test_tmf_payload = {
        "serviceCharacteristic": [
            {
                "id": "leaf1",
                "name": "leaf1",
                "valueType": "number",
                "value": 55.7
            }
        ],
        "serviceSpecification": {
            "id": "spec1",
        }
    }

    yang_schema = r"""module test {
    yang-version "1.1";
    namespace "http://example.com/test";
    prefix "tst";

    leaf leaf1 {
        type decimal64 {
            fraction-digits 2;
        }
    }
}
    """

    service = Service.from_json(test_tmf_payload)
    s = yang.compile([yang_schema])
    gd = yang.gen3.from_data(s, service.serviceCharacteristic)
    return gd.prsrc()

def _test_characteristic_integer():
    test_tmf_payload = {
        "serviceCharacteristic": [
            {
                "id": "leaf1",
                "name": "leaf1",
                "valueType": "integer",
                "value": 55
            }
        ],
        "serviceSpecification": {
            "id": "spec1",
        }
    }

    yang_schema = r"""module test {
    yang-version "1.1";
    namespace "http://example.com/test";
    prefix "tst";

    leaf leaf1 {
        type int32;
    }
}
    """

    service = Service.from_json(test_tmf_payload)
    s = yang.compile([yang_schema])
    gd = yang.gen3.from_data(s, service.serviceCharacteristic)
    return gd.prsrc()

def _test_characteristic_boolean():
    test_tmf_payload = {
        "serviceCharacteristic": [
            {
                "id": "leaf1",
                "name": "leaf1",
                "valueType": "boolean",
                "value": True
            }
        ],
        "serviceSpecification": {
            "id": "spec1",
        }
    }

    yang_schema = r"""module test {
    yang-version "1.1";
    namespace "http://example.com/test";
    prefix "tst";

    leaf leaf1 {
        type boolean;
    }
}
    """

    service = Service.from_json(test_tmf_payload)
    s = yang.compile([yang_schema])
    gd = yang.gen3.from_data(s, service.serviceCharacteristic)
    return gd.prsrc()

def _test_characteristic_enumeration():
    test_tmf_payload = {
        "serviceCharacteristic": [
            {
                "id": "leaf1",
                "name": "leaf1",
                "valueType": "string",
                "value": "example"
            }
        ],
        "serviceSpecification": {
            "id": "spec1",
        }
    }

    yang_schema = r"""module test {
    yang-version "1.1";
    namespace "http://example.com/test";
    prefix "tst";

    leaf leaf1 {
        type enumeration {
            enum "example";
            enum "other";
        }
    }
}
    """

    service = Service.from_json(test_tmf_payload)
    s = yang.compile([yang_schema])
    gd = yang.gen3.from_data(s, service.serviceCharacteristic)
    return gd.prsrc()

def _test_json_to_gdata_netinfra_router():
    tmf_spec = {
        "netinfra.router": (
            name="Router",
            description="Network Infrastructure Router"
        ),
    }
    json_data = {
        "serviceCharacteristic": [
            {
                "id": "name",
                "name": "name",
                "valueType": "string",
                "value": "ams-core-1"
            }
        ],
        "serviceSpecification": {
            "id": "netinfra.router"
        }
    }
    yang_schema = r"""module netinfra {
    yang-version "1.1";
    namespace "http://example.com/netinfra";
    prefix "ni";

    container netinfra {
        list router {
            key "name";
            leaf name {
                type string;
            }
        }
    }
}
    """
    top_schema = yang.compile([yang_schema])
    gd, _ = json_to_gdata(tmf_spec, json_data, top_schema)
    services = gd.children[_q("tmf-store")].children[_q("tmf640")].children[_q("service")]
    if isinstance(services, yang.gdata.List):
        for s in services.elements:
            s.children.pop(_q("serviceDate"))
            s.children.pop(_q("startDate"))
    return gd.prsrc()

def _test_get_json_netinfra_router():
    yang_schema = r"""module netinfra {
    yang-version "1.1";
    namespace "http://example.com/netinfra";
    prefix "ni";

    container netinfra {
        list router {
            key "name";
            leaf name {
                type string;
            }
        }
    }
}
    """
    top_schema = yang.compile([yang_schema])
    layer_config = yang.gdata.Container({
        yang.gdata.Id("http://example.com/netinfra", "netinfra"): yang.gdata.Container({
            yang.gdata.Id("http://example.com/netinfra", "router"): yang.gdata.List(
                [yang.gdata.Id("http://example.com/netinfra", "name")],
                ns='http://example.com/netinfra', module='netinfra', elements=[
                    yang.gdata.Container({
                        yang.gdata.Id("http://example.com/netinfra", "name"): yang.gdata.Leaf('ams-core-1')
                    })
                ])
        }, ns='http://example.com/netinfra', module='netinfra'),
        _q("tmf-store"): yang.gdata.Container({
            _q("tmf640"): yang.gdata.Container({
                _q("service"): yang.gdata.List(
                    [_q("id")], elements=[
                        yang.gdata.Container({
                            _q("id"): yang.gdata.Leaf('netinfra.router(ams-core-1)'),
                            _q("href"): yang.gdata.Leaf('/tmf-api/ServiceActivationAndConfiguration/v4/service/netinfra.router(ams-core-1)'),
                            _q("hasStarted"): yang.gdata.Leaf(True),
                            _q("isBundle"): yang.gdata.Leaf(False),
                            _q("isServiceEnabled"): yang.gdata.Leaf(True),
                            _q("isStateful"): yang.gdata.Leaf(False),
                            _q("name"): yang.gdata.Leaf('ams-core-1'),
                            _q("serviceDate"): yang.gdata.Leaf('2024-06-01T12:00:00Z'),
                            _q("startDate"): yang.gdata.Leaf('2024-06-01T12:00:00Z'),
                            _q("startMode"): yang.gdata.Leaf('1'),
                            _q("state"): yang.gdata.Leaf('active'),
                            _q("baseType"): yang.gdata.Leaf('Service'),
                            _q("schemaLocation"): yang.gdata.Leaf('/tmf-api/schema/Service/Service.schema.json'),
                            _q("type"): yang.gdata.Leaf('Service'),
                            _q("feature"): yang.gdata.List([_q("id")]),
                            _q("note"): yang.gdata.List([_q("id")]),
                            _q("place"): yang.gdata.List([_q("id")]),
                            _q("relatedEntity"): yang.gdata.List([_q("id")]),
                            _q("relatedParty"): yang.gdata.List([_q("id")]),
                            _q("serviceCharacteristic"): yang.gdata.List(
                                [_q("name")], elements=[
                                    yang.gdata.Container({
                                        _q("id"): yang.gdata.Leaf('name'),
                                        _q("name"): yang.gdata.Leaf('name'),
                                        _q("baseType"): yang.gdata.Leaf('Characteristic'),
                                        _q("schemaLocation"): yang.gdata.Leaf('/tmf-api/schema/Service/Characteristic.schema.json'),
                                        _q("type"): yang.gdata.Leaf('Characteristic'),
                                        _q("characteristicRelationship"): yang.gdata.List([_q("id")])
                                    })
                                ]),
                            _q("serviceOrderItem"): yang.gdata.List([_q("id")]),
                            _q("serviceRelationship"): yang.gdata.List([_q("id")]),
                            _q("serviceSpecification"): yang.gdata.Container({
                                _q("id"): yang.gdata.Leaf('netinfra.router'),
                                _q("baseType"): yang.gdata.Leaf('ServiceSpecificationRef'),
                                _q("schemaLocation"): yang.gdata.Leaf('/tmf-api/schema/Service/ServiceSpecificationRef.schema.json'),
                                _q("type"): yang.gdata.Leaf('ServiceSpecificationRef'),
                                _q("referredType"): yang.gdata.Leaf('ServiceSpecification')
                            }),
                            _q("supportingResource"): yang.gdata.List([_q("id")]),
                            _q("supportingService"): yang.gdata.List([_q("id")])
                        })
                    ])
            }, ns=_NS_TMF, module='orchestron-tmf')
        })
    })
    data = get_service_list_json(layer_config, top_schema)
    return json.encode_list(data, pretty=True)

def _test_json_to_gdata_edge_device_access_interface():
    tmf_spec = {
        "edge-device": (
            name="Edge Device",
            description="Edge Device"
        ),
        "edge-device.access-interface": (
            name="Access Interface",
            description="Access Interface of Edge Device"
        ),
    }
    json_data = {
        "serviceCharacteristic": [
            {
                "id": "interface-name",
                "name": "interface-name",
                "valueType": "string",
                "value": "GigabitEthernet0/1"
            },
            {
                "id": "speed",
                "name": "speed",
                "valueType": "integer",
                "value": 1000
            }
        ],
        "serviceSpecification": {
            "id": "edge-device.access-interface"
        },
        "supportingService": [
            {
                "serviceCharacteristic": [
                        {
                            "id": "device-name",
                            "name": "device-name",
                            "valueType": "string",
                            "value": "AM-CORE-1"
                        }
                    ],
                "serviceSpecification": {
                    "id": "edge-device"
                }
            }
        ],
    }
    yang_schema = r"""module edge {
  namespace "http://example.com/edge";
  prefix edge;

    list edge-device {
        key "device-name";
        leaf device-name {
            type string;
            description "Name of the edge device";
        }
        list access-interface {
            key "interface-name";
            leaf interface-name {
                type string;
                description "Name of the access interface";
            }
            leaf speed {
                type int32;
                description "Speed of the interface in Mbps";
            }
        }
    }
}"""
    top_schema = yang.compile([yang_schema])
    gd, _ = json_to_gdata(tmf_spec, json_data, top_schema)
    services = gd.children[_q("tmf-store")].children[_q("tmf640")].children[_q("service")]
    if isinstance(services, yang.gdata.List):
        for s in services.elements:
            s.children.pop(_q("serviceDate"))
            s.children.pop(_q("startDate"))
    return gd.prsrc()

def _test_json_to_gdata_edge_device_access_interface_vlan():
    tmf_spec = {
        "edge-device": (
            name="Edge Device",
            description="Edge Device"
        ),
        "edge-device.access-interface": (
            name="Access Interface",
            description="Access Interface of Edge Device"
        ),
        "edge-device.access-interface.vlan": (
            name="VLAN",
            description="VLAN Configuration of Access Interface"
        ),
    }
    json_data = {
        "serviceCharacteristic": [
            {
                "id": "vlan-id",
                "name": "vlan-id",
                "valueType": "integer",
                "value": 100
            }
        ],
        "serviceSpecification": {
            "id": "edge-device.access-interface.vlan"
        },
        "supportingService": [
            {
                "serviceCharacteristic": [
                    {
                        "id": "interface-name",
                        "name": "interface-name",
                        "valueType": "string",
                        "value": "GigabitEthernet0/1"
                    },
                    {
                        "id": "speed",
                        "name": "speed",
                        "valueType": "integer",
                        "value": 1000
                    }
                ],
                "serviceSpecification": {
                    "id": "edge-device.access-interface"
                },
                "supportingService": [
                    {
                        "serviceCharacteristic": [
                                {
                                    "id": "device-name",
                                    "name": "device-name",
                                    "valueType": "string",
                                    "value": "AM-CORE-1"
                                }
                            ],
                        "serviceSpecification": {
                            "id": "edge-device"
                        }
                    }
                ]
            }
        ]
    }

    yang_schema = r"""module edge {
  namespace "http://example.com/edge";
  prefix edge;

    list edge-device {
        key "device-name";
        leaf device-name {
            type string;
            description "Name of the edge device";
        }
        list access-interface {
            key "interface-name";
            leaf interface-name {
                type string;
                description "Name of the access interface";
            }
            leaf speed {
                type int32;
                description "Speed of the interface in Mbps";
            }
            list vlan {
                key "vlan-id";
                leaf vlan-id {
                    type uint16;
                    description "VLAN Identifier";
                }
            }
        }
    }
}"""
    top_schema = yang.compile([yang_schema])
    gd, _ = json_to_gdata(tmf_spec, json_data, top_schema)
    services = gd.children[_q("tmf-store")].children[_q("tmf640")].children[_q("service")]
    if isinstance(services, yang.gdata.List):
        for s in services.elements:
            s.children.pop(_q("serviceDate"))
            s.children.pop(_q("startDate"))
    return gd.prsrc()

def _test_get_json_edge_device_access_interface_vlan():
    yang_schema = r"""module edge {
  namespace "http://example.com/edge";
  prefix edge;

    list edge-device {
        key "device-name";
        leaf device-name {
            type string;
            description "Name of the edge device";
        }
        list access-interface {
            key "interface-name";
            leaf interface-name {
                type string;
                description "Name of the access interface";
            }
            leaf speed {
                type int32;
                description "Speed of the interface in Mbps";
            }
            list vlan {
                key "vlan-id";
                leaf vlan-id {
                    type uint16;
                    description "VLAN Identifier";
                }
            }
        }
    }
}"""
    top_schema = yang.compile([yang_schema])
    layer_config = yang.gdata.Container({
        yang.gdata.Id("http://example.com/edge", "edge-device"): yang.gdata.List(
            [yang.gdata.Id("http://example.com/edge", "device-name")],
            ns='http://example.com/edge', module='edge', elements=[
                yang.gdata.Container({
                    yang.gdata.Id("http://example.com/edge", "device-name"): yang.gdata.Leaf('AM-CORE-1'),
                    yang.gdata.Id("http://example.com/edge", "access-interface"): yang.gdata.List(
                        [yang.gdata.Id("http://example.com/edge", "interface-name")],
                        ns='http://example.com/edge', module='edge', elements=[
                            yang.gdata.Container({
                                yang.gdata.Id("http://example.com/edge", "interface-name"): yang.gdata.Leaf('GigabitEthernet0/1'),
                                yang.gdata.Id("http://example.com/edge", "speed"): yang.gdata.Leaf(bigint(1000)),
                                yang.gdata.Id("http://example.com/edge", "vlan"): yang.gdata.List(
                                    [yang.gdata.Id("http://example.com/edge", "vlan-id")],
                                    ns='http://example.com/edge', module='edge', elements=[
                                        yang.gdata.Container({
                                            yang.gdata.Id("http://example.com/edge", "vlan-id"): yang.gdata.Leaf(bigint(100))
                                        })
                                    ])
                            })
                        ])
                })
            ]),
        _q("tmf-store"): yang.gdata.Container({
            _q("tmf640"): yang.gdata.Container({
                _q("service"): yang.gdata.List(
                    [_q("id")], elements=[
                        yang.gdata.Container({
                            _q("id"): yang.gdata.Leaf('edge-device(AM-CORE-1).access-interface(GigabitEthernet0/1).vlan(100)'),
                            _q("href"): yang.gdata.Leaf('/tmf-api/ServiceActivationAndConfiguration/v4/service/edge-device(AM-CORE-1).access-interface(GigabitEthernet0/1).vlan(100)'),
                            _q("hasStarted"): yang.gdata.Leaf(True),
                            _q("isBundle"): yang.gdata.Leaf(False),
                            _q("isServiceEnabled"): yang.gdata.Leaf(True),
                            _q("isStateful"): yang.gdata.Leaf(False),
                            _q("name"): yang.gdata.Leaf('100'),
                            _q("serviceDate"): yang.gdata.Leaf('2024-06-01T12:00:00Z'),
                            _q("startDate"): yang.gdata.Leaf('2024-06-01T12:00:00Z'),
                            _q("startMode"): yang.gdata.Leaf('1'),
                            _q("state"): yang.gdata.Leaf('active'),
                            _q("baseType"): yang.gdata.Leaf('Service'),
                            _q("schemaLocation"): yang.gdata.Leaf('/tmf-api/schema/Service/Service.schema.json'),
                            _q("type"): yang.gdata.Leaf('Service'),
                            _q("feature"): yang.gdata.List([_q("id")]),
                            _q("note"): yang.gdata.List([_q("id")]),
                            _q("place"): yang.gdata.List([_q("id")]),
                            _q("relatedEntity"): yang.gdata.List([_q("id")]),
                            _q("relatedParty"): yang.gdata.List([_q("id")]),
                            _q("serviceCharacteristic"): yang.gdata.List(
                                [_q("name")], elements=[
                                    yang.gdata.Container({
                                        _q("id"): yang.gdata.Leaf('vlan-id'),
                                        _q("name"): yang.gdata.Leaf('vlan-id'),
                                        _q("baseType"): yang.gdata.Leaf('Characteristic'),
                                        _q("schemaLocation"): yang.gdata.Leaf('/tmf-api/schema/Service/Characteristic.schema.json'),
                                        _q("type"): yang.gdata.Leaf('Characteristic'),
                                        _q("characteristicRelationship"): yang.gdata.List([_q("id")])
                                    })
                                ]),
                            _q("serviceOrderItem"): yang.gdata.List([_q("id")]),
                            _q("serviceRelationship"): yang.gdata.List([_q("id")]),
                            _q("serviceSpecification"): yang.gdata.Container({
                                _q("id"): yang.gdata.Leaf('edge-device.access-interface.vlan'),
                                _q("baseType"): yang.gdata.Leaf('ServiceSpecificationRef'),
                                _q("schemaLocation"): yang.gdata.Leaf('/tmf-api/schema/Service/ServiceSpecificationRef.schema.json'),
                                _q("type"): yang.gdata.Leaf('ServiceSpecificationRef'),
                                _q("referredType"): yang.gdata.Leaf('ServiceSpecification')
                            }),
                            _q("supportingResource"): yang.gdata.List([_q("id")]),
                            _q("supportingService"): yang.gdata.List(
                                [_q("id")], elements=[
                                    yang.gdata.Container({
                                        _q("id"): yang.gdata.Leaf('edge-device(AM-CORE-1).access-interface(GigabitEthernet0/1)'),
                                        _q("href"): yang.gdata.Leaf('/tmf-api/ServiceActivationAndConfiguration/v4/service/edge-device(AM-CORE-1).access-interface(GigabitEthernet0/1)'),
                                        _q("name"): yang.gdata.Leaf('GigabitEthernet0/1'),
                                        _q("baseType"): yang.gdata.Leaf('ServiceRefOrValue'),
                                        _q("schemaLocation"): yang.gdata.Leaf('/tmf-api/schema/Service/ServiceRefOrValue.schema.json'),
                                        _q("type"): yang.gdata.Leaf('ServiceRefOrValue'),
                                        _q("serviceSpecification"): yang.gdata.Container({
                                            _q("id"): yang.gdata.Leaf('edge-device.access-interface'),
                                            _q("baseType"): yang.gdata.Leaf('ServiceSpecificationRef'),
                                            _q("schemaLocation"): yang.gdata.Leaf('/tmf-api/schema/Service/ServiceSpecificationRef.schema.json'),
                                            _q("type"): yang.gdata.Leaf('ServiceSpecificationRef'),
                                            _q("referredType"): yang.gdata.Leaf('ServiceSpecification')
                                        }),
                                        _q("feature"): yang.gdata.List([_q("id")]),
                                        _q("note"): yang.gdata.List([_q("id")]),
                                        _q("place"): yang.gdata.List([_q("id")]),
                                        _q("relatedEntity"): yang.gdata.List([_q("id")]),
                                        _q("relatedParty"): yang.gdata.List([_q("id")]),
                                        _q("serviceCharacteristic"): yang.gdata.List(
                                            [_q("name")], elements=[
                                                yang.gdata.Container({
                                                    _q("id"): yang.gdata.Leaf('interface-name'),
                                                    _q("name"): yang.gdata.Leaf('interface-name'),
                                                    _q("baseType"): yang.gdata.Leaf('Characteristic'),
                                                    _q("schemaLocation"): yang.gdata.Leaf('/tmf-api/schema/Service/Characteristic.schema.json'),
                                                    _q("type"): yang.gdata.Leaf('Characteristic'),
                                                    _q("characteristicRelationship"): yang.gdata.List([_q("id")])
                                                }),
                                                yang.gdata.Container({
                                                    _q("id"): yang.gdata.Leaf('speed'),
                                                    _q("name"): yang.gdata.Leaf('speed'),
                                                    _q("baseType"): yang.gdata.Leaf('Characteristic'),
                                                    _q("schemaLocation"): yang.gdata.Leaf('/tmf-api/schema/Service/Characteristic.schema.json'),
                                                    _q("type"): yang.gdata.Leaf('Characteristic'),
                                                    _q("characteristicRelationship"): yang.gdata.List([_q("id")])
                                                })
                                            ]),
                                        _q("serviceOrderItem"): yang.gdata.List([_q("itemId")]),
                                        _q("serviceRelationship"): yang.gdata.List([_q("id")]),
                                        _q("supportingResource"): yang.gdata.List([_q("id")]),
                                        _q("supportingService"): yang.gdata.List(
                                            [_q("id")], elements=[
                                                yang.gdata.Container({
                                                    _q("id"): yang.gdata.Leaf('edge-device(AM-CORE-1)'),
                                                    _q("href"): yang.gdata.Leaf('/tmf-api/ServiceActivationAndConfiguration/v4/service/edge-device(AM-CORE-1)'),
                                                    _q("name"): yang.gdata.Leaf('AM-CORE-1'),
                                                    _q("baseType"): yang.gdata.Leaf('ServiceRefOrValue'),
                                                    _q("schemaLocation"): yang.gdata.Leaf('/tmf-api/schema/Service/ServiceRefOrValue.schema.json'),
                                                    _q("type"): yang.gdata.Leaf('ServiceRefOrValue'),
                                                    _q("serviceSpecification"): yang.gdata.Container({
                                                        _q("id"): yang.gdata.Leaf('edge-device'),
                                                        _q("baseType"): yang.gdata.Leaf('ServiceSpecificationRef'),
                                                        _q("schemaLocation"): yang.gdata.Leaf('/tmf-api/schema/Service/ServiceSpecificationRef.schema.json'),
                                                        _q("type"): yang.gdata.Leaf('ServiceSpecificationRef'),
                                                        _q("referredType"): yang.gdata.Leaf('ServiceSpecification')
                                                    }),
                                                    _q("feature"): yang.gdata.List([_q("id")]),
                                                    _q("note"): yang.gdata.List([_q("id")]),
                                                    _q("place"): yang.gdata.List([_q("id")]),
                                                    _q("relatedEntity"): yang.gdata.List([_q("id")]),
                                                    _q("relatedParty"): yang.gdata.List([_q("id")]),
                                                    _q("serviceCharacteristic"): yang.gdata.List(
                                                        [_q("name")], elements=[
                                                            yang.gdata.Container({
                                                                _q("id"): yang.gdata.Leaf('device-name'),
                                                                _q("name"): yang.gdata.Leaf('device-name'),
                                                                _q("baseType"): yang.gdata.Leaf('Characteristic'),
                                                                _q("schemaLocation"): yang.gdata.Leaf('/tmf-api/schema/Service/Characteristic.schema.json'),
                                                                _q("type"): yang.gdata.Leaf('Characteristic'),
                                                                _q("characteristicRelationship"): yang.gdata.List([_q("id")])
                                                            })
                                                        ]),
                                                    _q("serviceOrderItem"): yang.gdata.List([_q("itemId")]),
                                                    _q("serviceRelationship"): yang.gdata.List([_q("id")]),
                                                    _q("supportingResource"): yang.gdata.List([_q("id")]),
                                                    _q("supportingService"): yang.gdata.List([_q("id")])
                                                })
                                            ])
                                    })
                                ])
                        })
                    ])
            }, ns=_NS_TMF, module='orchestron-tmf')
        })
    })
    data = get_service_list_json(layer_config, top_schema)
    return json.encode_list(data, pretty=True)
